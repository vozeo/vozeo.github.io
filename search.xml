<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[服务器OJ]]></title>
    <url>%2F2019%2F02%2F21%2F%E6%9C%8D%E5%8A%A1%E5%99%A8OJ%2F</url>
    <content type="text"><![CDATA[最近搭建了一个基于syzoj的OJ，把遇到的问题总结一下。 临时地址：http://39.105.15.76/ 搭建教程在这里，已经写的很清楚啦。 数据库需要输入密码的时候可以直接按回车跳过，否则需要输入mysql -p登录。 上传数据遇到413错误是因为nginx上传限制太小，修改配置文件即可。 出现cannot GET /重启一下服务就好了。 1systemctl restart syzoj-web 通过管理上传数据包出现403错误，安装p7zip-full即可解决。 1apt install p7zip-full]]></content>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ刷题表]]></title>
    <url>%2F2019%2F02%2F12%2FBZOJ%E5%88%B7%E9%A2%98%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[从网上转的BZOJ刷题列表。 难度0 题号 算法 思想难度 实现难度 总难度 推荐指数 1214 Ruby 0 0 0 10 3816 Ruby 0 0 0 10 1000 可持久化动态仙人掌剖分 1 1 2 10 2462 输出10个1 6 3 9 1 2463 小学奥数 10 2 12 2 1192 找规律/二分图 9 5 14 9 难度1 题号 算法 思想难度 实现难度 总难度 推荐指数 2659 数学 20 7 27 2 1968 枚举 15 13 28 2 2761 去重 12 18 30 6 3767 高精度A+B 10 20 30 2 1432 找规律 27 5 32 3 3098 随机卡HASH 23 10 33 2 1800 统计 20 16 36 3 1218 枚举 20 17 37 2 4001 找规律 28 9 37 3 2760 字符串处理 12 26 38 1 1088 DP/判断 22 17 39 6 1034 贪心 24 16 40 6 1207 DP 23 17 40 2 2748 DP 21 19 40 4 4302 分类讨论 29 11 40 1083 最小生成树 17 25 42 9 2563 转换后排序 27 15 42 7 3097 构造卡HASH 27 15 42 2 1022 简单博弈 30 13 43 3 2465 贪心 25 20 45 4 2122 暴力 28 18 46 2 1197 DP 31 19 50 2 1295 搜索 20 30 50 5 1821 最小生成树 25 25 50 4 难度2 题号 算法 思想难度 实现难度 总难度 推荐指数 2134 期望DP 30 20 50 4 1876 高精求GCD 18 33 51 2 2173 找规律 37 14 51 3 2208 暴力 23 28 51 2 1258 找规律 33 19 52 2 2005 数学 30 22 52 6 2429 最小生成树 23 29 52 3 2464 最短路 21 31 52 2 1028 枚举 26 27 53 4 2222 打表+手算 39 14 53 1 2456 脑补 34 19 53 6 4300 DP+单调转移 30 23 53 1008 数学分析+快速幂 27 27 54 7 1413 博弈 39 15 54 4 4368 贪心 31 23 54 1012 树状数组/线段树/RMQ 24 31 55 3 1228 博弈论SG函数 40 15 55 3 1489 DP 32 23 55 5 1607 线性筛因数 27 28 55 6 1050 并查集 27 29 56 8 1053 搜索 27 29 56 4 1261 DP 31 25 56 6 1303 前缀和 33 23 56 8 1569 DP 28 28 56 4 1970 暴力+高精 25 31 56 1 2241 暴力 28 28 56 2 1002 递推+高精度 32 25 57 2 1024 搜索 29 28 57 4 1054 BFS 27 30 57 5 1059 二分图 27 30 57 9 1191 二分图 27 30 57 9 1260 DP 32 25 57 6 1263 贪心+高精度 29 28 57 5 1816 二分 31 26 57 6 1854 二分图 27 30 57 6 1967 Floodfill最短路/贪心Cheat 42 15 57 1 3505 数学 29 28 57 4 4247 背包DP 31 26 57 1206 堆 27 31 58 3 1296 DP 33 25 58 6 1485 卡特兰数 29 29 58 3 1856 卡特兰数 29 29 58 3 2457 贪心 33 25 58 5 2467 找规律 37 21 58 3 2764 DP+高精度 26 32 58 2 1045&amp;3293 数学求中位数 33 25 58 5 1013 高斯消元 28 31 59 4 1025 DP 32 27 59 5 1078 模拟斜堆 31 28 59 4 1265 高精度 29 30 59 2 1433 二分图 29 30 59 4 1505 贪心 35 24 59 5 2048 数学 39 20 59 3 2156 最短路 29 30 59 2 3108 乱搞 36 23 59 4 3214 字符串处理 24 35 59 2 3668 进制乱搞 27 32 59 6 4195 离散化+并查集 28 31 59 4 1019 DP 35 25 60 3 1055 DP 33 27 60 6 1452 三维树状数组 27 33 60 3 1509 树上最长链 30 30 60 6 1867 DP 32 28 60 5 1965 快速幂+快速乘 30 30 60 7 2435 BFS 30 30 60 5 2705 欧拉函数 30 30 60 6 2783 树上倍增 30 30 60 6 3210 坐标转化 33 27 60 5 1015 并查集 32 29 61 8 1036 树链剖分/动态树 26 35 61 10 1047 二维RMQ 27 34 61 5 1084 DP 33 28 61 7 1213 二分+高精 25 36 61 1 3106 DP 31 30 61 5 3142 数学 36 25 61 5 3613 二分+贪心 33 28 61 4 1026 数位DP 31 31 62 6 1079 记忆化搜索 31 31 62 2 1081 模拟 32 30 62 4 1293 单调队列 31 31 62 7 1407 扩展欧几里得 32 30 62 5 1588 Splay/Set 27 35 62 4 1811 差分解方程 36 26 62 6 1879 状压DP 33 29 62 6 2190 线性筛欧拉函数 31 31 62 7 2426 贪心 33 29 62 4 2656 高精度 31 31 62 2 2751 快速幂+快速乘 31 31 62 6 3191 DP 36 26 62 6 3517 解方程 40 22 62 6 4233 递推 40 22 62 4 1031 后缀数组 27 36 63 6 1044 二分+DP 33 30 63 6 1076 期望DP 34 29 63 6 1089 递推+高精度 32 31 63 2 1103 树链剖分 27 36 63 6 1198 搜索 31 32 63 2 1208 Splay/Set 29 34 63 3 1216 堆 27 36 63 5 1224 DFS+剪枝 35 28 63 3 1257 数学 36 27 63 7 2150 二分图 32 31 63 8 2172 分类讨论+暴力 35 28 63 2 3155 树状数组 31 32 63 6 4008 期望DP 33 30 63 6 4318 期望 40 23 63 4403 卢卡斯 33 30 63 1269&amp;1507 Splay/STL 28 35 63 3 1416&amp;1498 高精度算概率 31 32 63 4 1010 DP单调性/斜率优化 32 32 64 8 1046 DP+贪心 34 30 64 5 1092 模拟 34 30 64 4 1259 打表 44 20 64 1 1304 树形DP 33 31 64 6 1406 数学 36 28 64 5 1820 DP 35 29 64 7 1996 DP 36 28 64 6 2153 DP斜率优化 32 32 64 5 2302 DP+组合数递推 35 29 64 6 2328 贪心 35 29 64 5 2338 计算几何+排序 32 32 64 6 2600 二分/单调性 34 30 64 6 2660 DP 32 32 64 5 2765 解方程 32 32 64 5 2824 搜索 34 30 64 2 2875 矩阵乘法 31 33 64 7 3175 二分图 33 31 64 9 3208 记忆化搜索 32 32 64 4 3223 Splay翻转 27 37 64 7 3224 Splay 26 38 64 8 3227 DP+打表 34 30 64 2 3288 线性筛+欧拉函数 32 32 64 6 3437 DP斜率优化 32 32 64 7 3444 数学 34 30 64 4 3612 DP 37 27 64 5 4321 DP 40 24 64 4401 枚举约数+树上统计 35 29 64 1007 单调栈 33 32 65 8 1048 记忆化搜索 34 31 65 6 1051 tarjan 30 35 65 5 1058 Splay/Set 29 36 65 4 1068 记忆化搜索 35 30 65 7 1087 状压DP 33 32 65 6 1202 并查集 33 32 65 8 1220 数学+高精度 34 31 65 2 1237 DP 39 26 65 6 1491 Floyd 33 32 65 7 1560 DP小优化 36 29 65 7 1801 DP 34 31 65 7 1864 树形DP 33 32 65 6 1899 DP 35 30 65 6 1911 DP斜率优化 32 33 65 8 1912 树上最长链 34 31 65 6 1925 DP 35 30 65 7 1966 DP 35 30 65 4 2049 LCT 27 38 65 7 2186 数学 32 33 65 7 2242 快速幂+逆元+BSGS 29 36 65 7 2335 分类讨论 39 26 65 3 2423 DP 36 29 65 6 2431 DP 35 30 65 6 2565 Manacher 33 32 65 7 2729 组合计数高精度 35 30 65 5 2822 卡特兰数+高精度 33 32 65 2 3156 DP斜率优化 32 33 65 6 3173 树状数组+倒求顺序 34 31 65 6 3190 单调栈 33 32 65 8 3212 线段树区间操作 27 38 65 9 3506 Splay 28 37 65 6 3609 博弈 40 25 65 4 3631 树链剖分 28 37 65 6 3643 暴力 33 32 65 4 4325 暴力 26 39 65 4385 单调队列 31 34 65 1787&amp;1832 LCA 31 34 65 6 1789&amp;1830 暴力 34 31 65 5 难度3 题号 算法 思想难度 实现难度 总难度 推荐指数 1003 DP+最短路 33 33 66 7 1029 贪心+堆 34 32 66 7 1032 错误DP 39 27 66 1 1037 DP 38 28 66 7 1057 DP悬线法 33 33 66 7 1060 树形DP 33 33 66 6 1086 树上DFS分块 33 33 66 2 1096 DP斜率优化 33 33 66 8 1149 DFS 34 32 66 6 1193 贪心+暴力 36 30 66 2 1196 二分+最小生成树 34 32 66 7 1212 Trie+DP 33 33 66 3 1222 DP 39 27 66 6 1806 DP 35 31 66 6 1819 暴力+字典树 32 34 66 2 1861 Splay 29 37 66 7 1932 STL 30 36 66 2 2120 暴力 38 28 66 2 2155 高精递推 39 27 66 4 2299 裴蜀定理 39 27 66 4 2330 差分约束 33 33 66 7 2461 DP 35 31 66 4 2466 树形DP 34 32 66 3 2657 构图+树上最长链 33 33 66 6 2762 树状数组 32 34 66 2 2819 树剖博弈 28 38 66 5 3170 曼哈顿距离 36 30 66 6 3172 AC自动机 30 36 66 9 3174 贪心+DP 36 30 66 6 3192 树状数组 34 32 66 5 3209 数位DP 34 32 66 5 3573 树形DP 33 33 66 4 3823 递推统计 35 31 66 4 3997 DP 37 29 66 5 1042 背包DP+容斥原理 35 32 67 7 1072 状压DP 35 32 67 6 1082 二分+搜索判断 34 33 67 6 1090 区间DP 35 32 67 7 1225 搜索+剪枝+高精 33 34 67 2 1277 DP 36 31 67 5 1486 二分+DFS找负环 34 33 67 8 1564 区间DP 35 32 67 6 1794 DP 37 30 67 5 1798 线段树 29 38 67 9 1860 DP 34 33 67 6 2281 博弈+DP 39 28 67 5 2440 二分+莫比乌斯容斥 34 33 67 6 2458 分治计算几何 34 33 67 7 2667 暴枚+解方程判断 35 32 67 6 2746 BFS 30 37 67 3 2767 DP 37 30 67 6 2809 可并堆 33 34 67 8 2818 欧拉函数/莫比乌斯反演 34 33 67 7 3107 构造 40 27 67 5 3226 线段树 30 37 67 4 3287 高精度 32 35 67 2 3555 HASH 34 33 67 5 4196 树链剖分 29 38 67 7 4236 MAP 35 32 67 6 4347 DP 38 29 67 4366 DP讨论 46 21 67 1180&amp;2843 LCT 28 39 67 5 1786&amp;1831 DP 36 31 67 5 1408 数论 40 28 68 2 1412 网络流 33 35 68 5 1434 博弈论 43 25 68 5 1497 最小割 33 35 68 9 1503 Splay 30 38 68 8 1562 二分图DFS序 34 34 68 8 1567 二分+HASH 34 34 68 5 1597 排序+DP斜率优化 34 34 68 8 1826 贪心+堆 35 33 68 7 1833 数位DP 34 34 68 7 1922 Dijkstra堆优 33 35 68 9 2038 莫队 32 36 68 9 2111 排列组合 34 34 68 3 2118 最短路 35 33 68 8 2160 Manacher+快速幂 34 34 68 7 2227 高精算概率 35 33 68 2 2654 二分+最小生成树 35 33 68 6 2661 费用流 34 34 68 6 2823 最小圆覆盖 29 39 68 7 3111 DP 35 33 68 6 3207 HASH/莫队/主席树 31 37 68 2 3211 暴力并查集+树状数组 35 33 68 4 3225 线段树扫描 32 36 68 2 3233 线性筛+DP 36 32 68 6 3442 费用流 34 34 68 6 3670 KMP 34 34 68 6 4337 HASH判树同构 33 35 68 4 4364 线段树 31 37 68 4378 树状数组 34 34 68 1056&amp;1862 Trie+Splay 28 40 68 3 1043 计算几何+贪心 33 36 69 7 1066 网络流 34 35 69 8 1221 费用流 35 34 69 9 1264 树状数组优化DP 36 33 69 5 1411 推猜结论 41 28 69 6 1855 DP+单调队列 35 34 69 8 1858 线段树各种操作 30 39 69 8 2002 LCT 31 38 69 6 2131 树状数组优化DP 36 33 69 7 2157 LCT多种操作 29 40 69 7 2226 数学 36 33 69 7 2298 DP 40 29 69 6 2460 拟阵+线性基 37 32 69 6 3105 拟阵+线性基 37 32 69 6 3195 状压DP 37 32 69 5 3289 莫队+BIT 32 37 69 6 3316 二分+单调队列 35 34 69 6 3671 贪心 36 33 69 7 3675 多维DP斜率优化 34 35 69 6 3884 费马+欧拉函数+快速幂 37 32 69 6 4004 线性基 36 33 69 8 4034 DFS序维护树 31 38 69 8 4084 HASH 32 37 69 5 4320 分块 36 33 69 1006 弦图染色 40 30 70 2 1041 数学 44 26 70 7 1052 二分+DFS 37 33 70 4 1150 贪心+堆 38 32 70 8 1151 状压DP 36 34 70 7 1188 博弈论SG函数 37 33 70 7 1483 链表启发式合并 35 35 70 7 1566 DP 38 32 70 7 1570 二分+网络流 35 35 70 4 1818 离散化+树状数组 35 35 70 5 1857 三分套三分 34 36 70 7 1877 费用流 36 34 70 7 1878 离线树状数组 36 34 70 8 1898 矩阵乘法 35 35 70 6 1923 高斯消元 36 34 70 8 2037 区间DP 39 31 70 7 2152 点分治 33 37 70 7 2243 树链剖分 30 40 70 7 2339 排列组合+快速幂 40 30 70 5 2424 费用流 36 34 70 7 2439 DP单调优化+扫描 37 33 70 5 2468 数学公式优化 38 32 70 6 2666 贪心调整 40 30 70 7 2957 分块 35 35 70 6 3109 搜索 32 38 70 5 3124 树形DP 36 34 70 6 3193 DP 40 30 70 6 3240 费马小定理+矩阵乘法 35 35 70 7 3436 差分约束+判负环 36 34 70 7 3531 树链剖分 30 40 70 7 3562 缩点+并查集 35 35 70 2 3624 最小生成树+贪心 37 33 70 6 3676 回文自动机 33 37 70 8 3680 模拟退火 33 37 70 8 3685 线段树 31 39 70 4 3732 Kruskal+树上倍增 34 36 70 8 3813 线段树+逆元 32 38 70 7 3930 数学 41 29 70 4 3993 二分+网络流 35 35 70 7 4003 可并堆 34 36 70 8 4027 树形DP 37 33 70 5 4031 矩阵树定理 35 35 70 7 4198 K叉哈夫曼 37 33 70 7 4319 构造SA 40 30 70 5 4338 分解质因数 38 32 70 4349 最小树形图 31 39 70 8 4370 线段树 30 40 70 1040 环+外向树DP 34 37 71 8 1063 树形DP 37 34 71 8 1070 费用流 37 34 71 7 1071 单调扫描 38 33 71 7 1143 Floyd+二分图 38 33 71 8 1217 树形贪心 38 33 71 7 1297 矩阵乘法 37 34 71 8 1415 期望+记忆化DP 37 34 71 8 1484 贪心调整 42 29 71 7 1799 数位DP 36 35 71 6 1834 最大流+费用流 34 37 71 5 1910 DP 38 33 71 6 1935 离线树状数组 36 35 71 5 1975 K短路 33 38 71 7 2133 树形DP 37 34 71 6 2151 双向链表+贪心+堆 37 34 71 8 2169 DP 41 30 71 7 2245 费用流 36 35 71 6 2257 裴蜀定理 38 33 71 4 2306 倍增+Floyd 37 34 71 7 2326 矩阵乘法 37 34 71 5 2337 期望高斯消元 36 35 71 7 2542 费用流 35 36 71 4 2560 子集DP 39 32 71 7 2743 离线树状数组 36 35 71 8 3130 二分+网络流 36 35 71 7 3231 矩阵乘法 35 36 71 4 3560 数论 37 34 71 6 3566 树形DP 38 33 71 6 3996 网络流 36 35 71 5 4029 模拟 39 32 71 4 4240 树状数组 40 31 71 4244 DP 41 30 71 4312 分类讨论 43 28 71 4 4326 树剖/讨论求链交 32 39 71 7 1306&amp;3139 搜索+剪枝 40 31 71 6 2662&amp;2763 分层图+Dijkstra堆优化 35 36 71 8 1005 Prufer 37 35 72 7 1061 单纯形 34 38 72 8 1069 旋转卡壳 33 39 72 8 1093 tarjan缩点+DP 36 36 72 9 1179 tarjan缩点+SPFA 35 37 72 9 1211 Prufer 39 33 72 3 1227 离散化+树状数组扫描 35 37 72 7 1266 最短路+最小割 35 37 72 8 1499 DP单调优化 35 37 72 6 1568 线段树 34 38 72 6 1823 2-SAT 36 36 72 7 1853 搜索+剪枝+容斥原理 39 33 72 6 1927 费用流 38 34 72 9 2142 扩展lucas 33 39 72 8 2163 最小割 37 35 72 4 2438 tarjan缩点 36 36 72 4 2588 DFS序+可持久化线段树 31 41 72 8 2733 Splay启发式合并 33 39 72 7 2742 数论 39 33 72 5 2749 转化后递推 42 30 72 6 2753 最小生成树 40 32 72 5 2816 LCT 31 41 72 5 2827 动态开点线段树 32 40 72 6 2962 线段树 33 39 72 7 2964 DP 36 36 72 5 3143 期望高斯消元 36 36 72 8 3144 最小割 37 35 72 6 3150 高斯消元 38 34 72 6 3152 贪心+堆 37 35 72 4 3295 分块统计动态逆序对 34 38 72 8 3333 BIT+线段树 34 38 72 5 3507 HASH+DP 37 35 72 5 3570 物理+树状数组 38 34 72 3 3576 博弈论+分块 41 31 72 6 3578 Set+rand Hash 36 36 72 4 3594 DP树状数组优化 39 33 72 4 3620 暴力+KMP 38 34 72 2 3629 判素数+约数和公式+暴力 38 34 72 4 3679 数位DP 36 36 72 5 3738 扩展lucas 32 40 72 5 3810 记忆化+卡常 37 35 72 6 3944 杜教筛 36 36 72 8 3673&amp;3674 可持久化ROPE 36 36 72 4 1016 最小生成树+DFS 40 33 73 6 1030 AC自动机+DP 36 37 73 8 1077 差分约束+Floyd 39 34 73 8 1085 A* 38 35 73 8 1177 分类讨论 36 37 73 4 1189 二分+网络流 37 36 73 6 1223 数位DP+高精度 36 37 73 2 1812 树形DP 40 33 73 8 1822 二分+网络流 35 38 73 4 1933 DP 41 32 73 7 1951 卢卡斯+CRT 38 35 73 7 2115 找环+线性基 38 35 73 8 2124 分类讨论分治+Cheat 40 33 73 2 2141 分块统计动态逆序对 34 39 73 8 2146 凸包+单调队列 37 36 73 5 2425 数位DP 40 33 73 6 2427 tarjan缩点+树上背包 36 37 73 7 2523 智商题 45 28 73 3 2618 半平面交 30 43 73 5 2752 线段树大力维护 33 40 73 7 2844 拟阵+线性基+找规律 40 33 73 6 3085 搜索+剪枝+高精度 35 38 73 2 3140 暴力+二分图匹配 37 36 73 6 3171 费用流 38 35 73 7 3238 后缀数组+单调栈 35 38 73 7 3329 数位DP+矩阵乘法 36 37 73 5 3330 三分套三分 36 37 73 4 3441 BIT+二分 39 34 73 5 3503 异或高斯消元 39 34 73 7 3621 数学 38 35 73 2 3931 最短路+网络流 35 38 73 8 3998 后缀自动机 35 38 73 8 3999 树链剖分 32 41 73 6 4007 DP 37 36 73 7 4028 set+分块 35 38 73 6 4153 链表合并+set 38 35 73 5 4243 并查集统计 39 34 73 4245 按位线性基调整 40 33 73 1934&amp;2768 网络流 38 35 73 8 1014 Splay+二分HASH 34 40 74 8 1017 树形DP 38 36 74 4 1049 LIS+DP 40 34 74 3 1073 K短路 35 39 74 4 1185 旋转卡壳 36 38 74 8 1190 分层背包 40 34 74 7 1226 状压DP 40 34 74 8 1305 二分+网络流 38 36 74 8 1444 AC自动机+矩阵乘法 36 38 74 7 1500 Splay各种操作 33 41 74 10 1875 矩阵乘法+拆边构图 39 35 74 8 1880 最短路+拓扑 37 37 74 7 1930 费用流 40 34 74 7 1941 K-D树 33 41 74 7 2004 矩阵乘法 36 38 74 7 2121 DP 40 34 74 7 2135 贪心+堆 39 35 74 6 2143 Dijkstra堆优不建边分层图 35 39 74 5 2301 容斥+莫比乌斯反演+前缀和 38 36 74 8 2336 搜索+随机化 39 35 74 5 2342 Manacher+并查集 40 34 74 6 2622 最短路变形 39 35 74 6 2648 K-D树 33 41 74 7 2728 推性质+按位统计 41 33 74 6 2958 DP 42 32 74 7 3083 树链剖分+DFS序讨论 34 40 74 7 3122 数列求和分类讨论逆元+BSGS 38 36 74 7 3198 HASH+容斥 36 38 74 6 3294 DP+容斥 41 33 74 8 3534 矩阵树定理 39 35 74 6 3564 最小圆覆盖 34 40 74 3 3744 分块在线统计逆序对 35 39 74 8 3751 HASH判方程 40 34 74 8 3875 SPFA维护DP 39 35 74 6 3932 差分主席树 34 40 74 6 3938 离线李超线段树 34 40 74 7 4000 矩阵乘法 36 38 74 5 4010 拓扑+堆 38 36 74 7 4013 树形DP 39 35 74 7 4033 树形DP 39 35 74 7 4152 排序+最短路 38 36 74 5 4237 分治+统计 37 37 74 4239 优先队列+二分 38 36 74 4241 分块 34 40 74 4299 主席树 38 36 74 8 1001 平面图转对偶图+最短路 37 38 75 8 1004 Poyla定理+DP+逆元 39 36 75 8 1009 KMP+矩阵乘法 38 37 75 8 1021 DP+优化 39 36 75 7 1027 凸包+最短路 36 39 75 4 1067 线段树分类讨论 36 39 75 2 1195 AC自动机+状压BFS 37 38 75 4 1449 费用流 40 35 75 8 1453 线段树+并查集 36 39 75 7 1917 树形贪心 43 32 75 7 1924 tarjan 35 40 75 4 1937 KM 39 36 75 7 2119 分段HASH 40 35 75 7 2128 按权值分块 35 40 75 7 2164 树剖背包 33 42 75 6 2244 三维偏序 36 39 75 4 2303 并查集+讨论 41 34 75 7 2561 网络流 39 36 75 6 2744 转化后二分图 40 35 75 6 2746 AC自动机+FAIL树LCA 37 38 75 7 2750 最短路+DP 41 34 75 7 2956 推公式+分块 40 35 75 6 3091 LCT各种操作大力维护 34 41 75 8 3112 单纯形 36 39 75 7 3203 三分+单调队列 38 37 75 6 3597 二分+DFS找负环 41 34 75 6 3626 离线树链剖分 34 41 75 6 3636 分治+DP 38 37 75 7 3926 后缀自动机 37 38 75 8 3934 插头DP 38 37 75 6 3956 单调栈+RMQ 41 34 75 7 4002 矩阵乘法+推公式 41 34 75 5 4017 按位统计+树状数组 39 36 75 6 4037 矩阵乘法 38 37 75 5 4289 Dijkstra 39 36 75 4404 BFS+打表 39 36 75 1487&amp;4316 仙人掌DP 36 39 75 7 2109&amp;2535 拓扑逆向加边 40 35 75 7 1194 BFS+tarjan缩点最长路 38 38 76 8 1298 构造 41 35 76 8 1443 二分图+判断 41 35 76 8 1913 极角排序统计贡献 43 33 76 7 1997 2-SAT 40 36 76 4 1998 并查集+置换 40 36 76 7 2007 平面图转对偶图+最短路 38 38 76 7 2129 多次前缀和处理 40 36 76 5 2145 密码学 37 39 76 1 2553 AC自动机+矩阵乘法 37 39 76 7 2568 按位BIT 39 37 76 4 2597 费用流 42 34 76 7 3622 容斥DP 44 32 76 8 3630 最小割 37 39 76 7 3874 单调贪心+三分 40 36 76 4 3990 暴力 40 36 76 7 3991 虚树+SET 35 41 76 8 4128 矩阵求逆 38 38 76 4 4238 生成树找环讨论 41 35 76 4260 (可持久化)Trie树 36 40 76 4380 区间DP 40 36 76 4381 分块暴力 36 40 76 1023 仙人掌求直径 38 39 77 6 1178 线段扫描+贪心+倍增预处理 40 37 77 8 1199 K-D树 35 42 77 6 1294 射线法+BFS 40 37 77 8 1493 线段树染色+讨论 36 41 77 7 2003 搜索+剪枝 41 36 77 6 2006 RMQ+堆 39 38 77 8 2228 DP+单调队列 41 36 77 8 2436 DP+单调优化 42 35 77 7 2595 斯坦纳树 35 42 77 7 2754 AC自动机 38 39 77 6 2756 二分+网络流 40 37 77 7 2811 贪心 40 37 77 7 2879 费用流动态加边 41 36 77 8 3064 线段树 34 43 77 7 3110 树套树 35 42 77 8 3123 DFS序可持久化线段树启发并 34 43 77 8 3131 数位DP+堆 39 38 77 7 3168 高斯求逆+二分图匹配 40 37 77 6 3243 随机化构造 40 37 77 2 3244 DFS序+统计答案 45 32 77 6 3438 最小割 42 35 77 8 3439 Trie+DFS序主席树 36 41 77 7 3504 网络流 41 36 77 5 3527 FFT 37 40 77 8 3641 环套树剖分 35 42 77 8 3669 LCT维护MST 36 41 77 8 4011 朱刘算法推论+树形DP 43 34 77 7 4026 主席树 37 40 77 8 4151 树上DFS 44 33 77 7 4199 后缀树DP 37 40 77 8 4346 树形DP 39 38 77 4377 扫描处理范围 39 38 77 1038 模拟退火 39 39 78 5 1074 计算几何 38 40 78 7 1095 动态树分治 37 41 78 9 1187 插头DP 37 41 78 8 1210 插头DP 37 41 78 1 1502 辛普森积分 38 40 78 7 1559 AC自动机DP+暴力 37 41 78 3 1791 基环树找直径 37 41 78 8 1972 暴力 29 49 78 2 2127 最小割 42 36 78 7 2132 网络流 42 36 78 7 2139 贪心+最小生成树 46 32 78 7 2140 Trie+tarjan 42 36 78 8 2154 莫比乌斯反演 42 36 78 7 2229 分治+最小割 39 39 78 6 2286 虚树DP 37 41 78 7 2333 可并堆套可并堆 36 42 78 7 2428 模拟退火 41 37 78 5 2539 KM 37 41 78 3 2564 凸包 43 35 78 4 2594 离线LCT维护动态MST 36 42 78 8 2730 双联通分量 40 38 78 7 3125 插头DP 37 41 78 7 3129 扩展lucas+容斥 38 40 78 8 3158 网络流 42 36 78 7 3196 树套树 32 46 78 9 3241 分类讨论DP 39 39 78 2 3246 树形DP 40 38 78 7 3530 AC自动机+数位DP 39 39 78 7 3577 网络流RMQ构图 40 38 78 7 3619 BFS构造+暴力 37 41 78 8 3678 Splay 35 43 78 6 4006 斯坦纳树 35 43 78 7 4035 博弈 45 33 78 7 4313 DP 43 35 78 7 4373 线段树 40 38 78 4399 线段树合并 35 43 78 1999&amp;2282 树上DFS+单调队列 40 38 78 7 3157&amp;3516 数学 45 33 78 6 1011 乱搞 49 30 79 2 1064 图论分类讨论 43 36 79 8 1494 最小表示法+矩阵乘法 38 41 79 7 1495 树形DP 41 38 79 7 1565 拓扑+最小割 42 37 79 8 1969 LCT维护边双 37 42 79 7 2137 分类讨论+求K次幂前缀和 39 40 79 6 2170 插头DP 38 41 79 7 2324 Floyd+费用流 42 37 79 8 2437 二分图+判断 43 36 79 8 2668 费用流 44 35 79 8 2669 DP+搜索容斥 42 37 79 6 2876 二分+数学 46 33 79 5 3242 环套树DP 38 41 79 7 3571 分治+KM 40 39 79 6 3611 虚树DP 37 42 79 8 3873 悬线法+根号分类讨论 39 40 79 6 3876 费用流 43 36 79 7 3935 单纯形 40 39 79 6 4005 数形结合 47 32 79 6 4336 树剖套set 33 46 79 6 4345 堆 41 38 79 4358 分块+并查集 40 39 79 4361 DP+BIT优化+容斥 45 34 79 1018 线段树维护连通性+大力讨论 37 43 80 8 1492 CDQ分治优化DP 40 40 80 8 1926 分块+莫队 36 44 80 7 2000 双端链表 44 36 80 8 2034 贪心调整 47 33 80 7 2159 二项式定理斯特林+树DP 45 35 80 7 2441 BIT+扫描线 40 40 80 3 2547 二分BFS+匈牙利 41 39 80 6 2707 tarjan+期望高斯 40 40 80 8 2734 状压DP 47 33 80 7 2741 分块+可持久化Trie 38 42 80 7 3513 FFT 40 40 80 8 3533 线段树+凸壳三分 37 43 80 6 3561 莫比乌斯反演 44 36 80 8 3720 块状树 37 43 80 7 3743 树形DP 38 42 80 7 4025 LCT维护二分图 37 43 80 7 4032 后缀自动机+序列自动机+BFS 40 40 80 7 4154 K-D树 37 43 80 8 4155 网络流+bitset压位DP 40 40 80 5 4242 BFS建图+货车运输 39 41 80 8 4317 动态树分治 37 43 80 6 4386 矩阵乘法 41 39 80 8 难度4 题号 算法 思想难度 实现难度 总难度 推荐指数 1033 模拟 31 50 81 8 1094 计算几何 39 42 81 7 1200 贪心+DP 47 34 81 8 2039 最小割 44 37 81 7 2331 插头DP 39 42 81 5 2433 计算几何+最短路 43 38 81 7 2459 线段树维护连通性+大力讨论 37 44 81 7 2548 暴力模拟 30 51 81 7 2726 CDQ分治优化DP 41 40 81 6 2806 广义后缀自动机+DP单调优化 41 40 81 8 3309 莫比乌斯反演+推性质 44 37 81 7 3677 树形DP 43 38 81 6 3786 Splay维护括号序列 38 43 81 6 3811 线性基+暴力 44 37 81 7 3925 子集DP 46 35 81 8 4016 Dijkstra+树分治 37 44 81 5 4036 反演子集求概率 50 31 81 7 4180 后缀自动机+倍增DP 41 40 81 6 4311 分治线段树挂链+凸壳三分 38 43 81 8 4372 动态树分治+BIT 37 44 81 6 4383 线段树挂链 39 42 81 2961&amp;4140 二进制分组+凸壳三分 39 42 81 8 1758 树分治+二分+单调队列 39 43 82 8 1797 最小割+tarjan判断 43 39 82 7 1835 线段树优化DP 43 39 82 8 2125 静态仙人掌 39 43 82 7 2780 广义后缀自动机+离线BIT 40 42 82 8 2960 平面图转对偶图+最小树形图 36 46 82 7 3232 二分+网络流 45 37 82 7 3529 莫比乌斯反演+离线树状数组 43 39 82 8 3532 网络流 44 38 82 8 3879 后缀树+虚树 36 46 82 6 4129 树上带修莫队+权值分块 38 44 82 8 4197 状压DP 45 37 82 8 4246 极角排序扫描统计贡献 45 37 82 4310 二分+后缀树 40 42 82 7 4384 乱搞+Cheat 45 37 82 1974 转化后DP 46 37 83 8 2001 动态MST 40 43 83 8 2126 转化后状压矩乘 45 38 83 8 2671 莫比乌斯反演 47 36 83 6 2959 LCT维护边双 39 44 83 8 3218 主席树优化网络流 42 41 83 8 3229 石子合并加强 48 35 83 3 3482 分层图最短路+单调统计 42 41 83 8 3994 莫比乌斯反演 46 37 83 7 3995 线段树维护连通性 38 45 83 7 4092 DP 47 36 83 8 2209&amp;2329 Splay大力维护 39 44 83 8 1558 线段树大力维护 41 43 84 8 2434 AC自动机+FAIL树状数组 43 41 84 8 2878 基环树DP 41 43 84 7 3160 FFT+Manacher 42 42 84 8 3637 有向LCT维护虚边 40 44 84 8 3672 树剖+凸壳三分 39 45 84 8 3681 主席树合并优化网络流 43 41 84 8 3730 动态树分治+动态开点线段树 38 46 84 7 3745 单调队列+线段树大力维护 40 44 84 7 4134 博弈+Trie合并 44 40 84 7 4367 主席树 42 42 84 8 4389 LCT维护虚边 38 46 84 8 4402 计数 45 39 84 2613 置换+构造 46 39 85 6 2651 树形DP 40 45 85 7 2815 LCA重构树 47 38 85 7 3514 LCT维护MST+主席树 40 45 85 8 3591 状压DP 50 35 85 8 3616 K-D树+BITSET 41 44 85 8 3640 高斯求逆优化 48 37 85 8 3817 类欧几里得 50 35 85 6 4066 K-D树+重建 37 48 85 8 1065 环套树DP 48 38 86 8 2555 后缀自动机+LCT 38 48 86 8 3519 Set大力维护 36 50 86 8 3572 虚树 39 47 86 8 3812 DP+容斥 50 36 86 7 3992 NTT+DP快速幂优化 45 41 86 8 4379 树形DP 40 46 86 1414 Manacher+RMQ+单调队列 46 41 87 8 2040 树剖+线段树模拟费用流 39 48 87 7 3461 CDQ分治优化DP 46 41 87 8 3489 三维K-D树 43 44 87 8 3639 有向LCT维护虚边 41 46 87 8 4012 可持久化树链剖分 40 47 87 8 3237&amp;3563&amp;3569 随机化造树+线性基 50 37 87 8 3065 替罪羊树套权值线段树 39 49 88 9 3413 后缀树+主席树 42 46 88 8 3512 杜教筛+莫比乌斯反演 51 37 88 8 3600 替罪羊树+线段树 46 42 88 8 4545 后缀自动机+LCT 39 49 88 8 1062 树状数组 51 38 89 8 2144 转化为LCA后二分+快速统计 53 36 89 8 2149 CDQ分治优化DP 46 43 89 8 2653 按值建主席树 43 46 89 8 3551 Kruskal重构树+DFS序主席树 49 40 89 8 4382 HASH+单调扫描 50 39 89 2162 转化后网络流+容斥DP 51 39 90 8 3814 插头DP 41 49 90 7 1020 迭代法+射线法+点到线段距离 43 48 91 8 4348 暴力 41 50 91 8 2566 动态树分治+map套set 41 51 92 7 2965 平面图转对偶图+枚举+最小割 43 51 94 8 2658 fhqtreap 52 43 95 8 2759 LCT维护环套树大力讨论 48 48 96 8]]></content>
      <tags>
        <tag>题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统修复]]></title>
    <url>%2F2019%2F01%2F21%2F%E7%B3%BB%E7%BB%9F%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[最近电脑一直出问题，连着修了5天电脑。总结一下遇到的问题。 仅适用于UEFI+GPT引导。 Windows重建EFI分区需要在磁盘上存在一部分未分配空间（大于100M），重新建立EFI分区并建立引导。 1234567diskpartlist diskselect disk * //选择要重建的EFI分区的编号create partition efi size = 500 //分配给EFI分区的容量format quick fs = fat32exitbcdboot c:\windows 重建UEFI引导在Windows安装盘或者WinPE中给EFI分区分配盘符，重新建立引导。 1bcdboot c:\windows /s g: /f uefi /l zh-cn //g是EFI分区 修复UEFI引导在Windows安装盘或者WinPE中给EFI分区分配盘符。 12345X:&gt; DISKPARTDISKPART&gt; list volDISKPART&gt; sel vol * //设置操作默认卷编号DISKPART&gt; assign letter=G:DISKPART&gt; exit 修复引导记录并重建BCD。 12345cd /d G:\EFI\Microsoft\BootG:\EFI\Microsoft\Boot&gt; bootrec /scanosG:\EFI\Microsoft\Boot&gt; bootrec /fixmbrG:\EFI\Microsoft\Boot&gt; bootrec /fixbootG:\EFI\Microsoft\Boot&gt; bootrec /rebuildbcd 修复BCD。 1G:\EFI\Microsoft\Boot&gt; bcdboot c:\windows /s g: /f all Linux修复grub引导开机出现了grub&gt;使用ls命令罗列所有磁盘分区信息，找到Linux安装分区，设置变量，进入grub启动菜单。 12345grub&gt;lsgrub&gt;root=(hd0,gpt3) grub&gt;prefix=(hd0,gpt3)/boot/grubgrub&gt;insmod /boot/grub/x86_64-efi/normal.modgrub&gt;normal 安装grub用以上方法重新进入Linux后，重新安装grub。 1update-grub 开机显示you are in emergency mode是由于修改了EFI分区，盘符UUID不对所致。查看/var/log/boot.log可看到启动时的UUID；把/etc/fstab中的UUID修改成新盘符的UUID。]]></content>
      <tags>
        <tag>linux 配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树学习笔记]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[近日新学习了线段树，总结一下它的用法和注意事项。 query和modify都不需要取$mid$，只有build需要。 有取模时应该每步取模。 区间的端点现算出来而不记录会更快，可以记录区间的长度。 如果有多种操作且不可叠加时pushdown放在前面，且特判叶结点；如果操作可叠加或者只有一种就放在后面。 模板1 已知一个数列，进行两种操作： 将某区间每一个数加上一个数； 求出某区间每一个数的和； 区间修改，区间查询，最简单的模板。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;iostream&gt;typedef long long ll;const int N = 100005;int n, m;ll a[N], ret;struct Node &#123; int len; Node *lc, *rc; ll sum, tag; Node() &#123;&#125; Node(ll val) : len(1), lc(NULL), rc(NULL), sum(val), tag(0) &#123;&#125; Node(Node *lc, Node *rc, int l) : len(l), lc(lc), rc(rc), tag(0) &#123; sum = lc-&gt;sum + rc-&gt;sum; &#125; void add(ll d) &#123; sum += len * d; tag += d; &#125; void pushdown() &#123; if (tag) &#123; lc-&gt;add(tag); rc-&gt;add(tag); tag = 0; &#125; &#125; void modify(int l, int r, int nl, int nr, ll d) &#123; if (nr &lt; l || r &lt; nl) return; if (l &lt;= nl &amp;&amp; nr &lt;= r) &#123; add(d); return; &#125; pushdown(); int mid = (nl + nr) &gt;&gt; 1; lc-&gt;modify(l, r, nl, mid, d); rc-&gt;modify(l, r, mid + 1, nr, d); sum = lc-&gt;sum + rc-&gt;sum; &#125; void query(int l, int r, int nl, int nr) &#123; if (nr &lt; l || r &lt; nl) return; if (l &lt;= nl &amp;&amp; nr &lt;= r) &#123; ret += sum; return; &#125; pushdown(); int mid = (nl + nr) &gt;&gt; 1; lc-&gt;query(l, r, nl, mid); rc-&gt;query(l, r, mid + 1, nr); &#125;&#125; *segt, tpool[N &lt;&lt; 1], *tcur = tpool;Node *build (int l, int r) &#123; if (l == r) return new(tcur++) Node(a[l]); int mid = (l + r) &gt;&gt; 1; return new(tcur++) Node(build(l, mid), build(mid + 1, r), r - l + 1);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf("%lld", &amp;a[i]); segt = build(1, n); int s, x, y; ll k; for (int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d", &amp;s, &amp;x, &amp;y); if (s == 1) &#123; scanf("%lld", &amp;k); segt-&gt;modify(x, y, 1, n, k); &#125; else &#123; ret = 0; segt-&gt;query(x, y, 1, n); printf("%lld\n", ret); &#125; &#125; return 0;&#125; 模板2 已知一个数列，进行两种操作： 将某区间每一个数乘上一个数； 将某区间每一个数加上一个数； 求出某区间每一个数的和 区间修改，区间查询，修改有加有乘。 在结点维护$kx+b$，$k$和$b$分开算，在乘$k$时把$k$和$b$都乘$k$，$k$初始化为$1$。 注意把pushdown放在前面，每次修改前先下传标记。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;typedef long long ll;const int N = 100005;int n, m;ll MOD, a[N];struct Node &#123; int l, r; Node *lc, *rc; ll sum, k, b; Node() &#123;&#125; Node(int pos, ll val) : l(pos), r(pos), lc(NULL), rc(NULL), sum(val), k(1), b(0) &#123;&#125; Node(Node *lc, Node *rc) : l(lc-&gt;l), r(rc-&gt;r), lc(lc), rc(rc), k(1), b(0) &#123; sum = (lc-&gt;sum + rc-&gt;sum) % MOD; &#125; void addk(ll d) &#123; sum = sum * d % MOD; k = k * d % MOD; b = b * d % MOD; &#125; void addb(ll d) &#123; sum = (sum + (r - l + 1) * d) % MOD; b = (b + d) % MOD; &#125; void pushdown() &#123; if (k != 1) &#123; lc-&gt;addk(k); rc-&gt;addk(k); k = 1; &#125; if (b) &#123; lc-&gt;addb(b); rc-&gt;addb(b); b = 0; &#125; &#125; void modify(int s, int l, int r, ll d) &#123; if (r &lt; this-&gt;l || this-&gt;r &lt; l) return; if (this-&gt;l != this-&gt;r) pushdown(); if (l &lt;= this-&gt;l &amp;&amp; this-&gt;r &lt;= r) &#123; if (s == 1) addk(d); else addb(d); return; &#125; lc-&gt;modify(s, l, r, d); rc-&gt;modify(s, l, r, d); sum = (lc-&gt;sum + rc-&gt;sum) % MOD; &#125; ll query(int l, int r) &#123; if (r &lt; this-&gt;l || this-&gt;r &lt; l) return 0; if (this-&gt;l != this-&gt;r) pushdown(); if (l &lt;= this-&gt;l &amp;&amp; this-&gt;r &lt;= r) return sum; return (lc-&gt;query(l, r) + rc-&gt;query(l, r)) % MOD; &#125;&#125; *root, tpool[N &lt;&lt; 1], *tcur = tpool;Node *build(int l, int r) &#123; if (l == r) return new (tcur++) Node(l, a[l]); int mid = (l + r) &gt;&gt; 1; return new (tcur++) Node(build(l, mid), build(mid + 1, r));&#125;int main() &#123; scanf("%d%d%lld", &amp;n, &amp;m, &amp;MOD); for (int i = 1; i &lt;= n; ++i) scanf("%lld", &amp;a[i]); root = build(1, n); int p, x, y; ll d; for (int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d", &amp;p, &amp;x, &amp;y); if (p == 3) printf("%lld\n", root-&gt;query(x, y)); else &#123; scanf("%lld", &amp;d); root-&gt;modify(p, x, y, d); &#125; &#125; return 0;&#125; 模板3 已知一个数列，进行5种操作： 把区间内的所有数都增加一个数； 把区间内的所有数都设为一个数； 查询区间的区间和； 查询区间的最大值； 查询区间的最小值。 要维护的量比较多，注意set和add的顺序。 这里放了kyr1no学长的代码$Orz$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;bits/stdc++.h&gt;typedef long long ll;typedef const int cint;typedef const long long cll;typedef const char cchar;#define daze &lt;&lt; '\n'template &lt;cint LI, cint LO&gt;struct IO &#123; char a[LI], b[LO], r[LO], *s, *t, *z, c; std::streambuf *fbi, *fbo; IO() : z(b) &#123; std::ios::sync_with_stdio(false); if (LI) std::cin.tie(NULL), fbi = std::cin.rdbuf(); if (LO) std::cout.tie(NULL), fbo = std::cout.rdbuf(); &#125; ~IO() &#123; if (LO) fbo-&gt;sputn(b, z - b); &#125; char gc() &#123; if (s == t) t = (s = a) + fbi-&gt;sgetn(a, LI); return s == t ? EOF : *s++; &#125; template &lt;class T&gt; IO &amp;operator &gt;&gt; (T &amp;x) &#123; for (c = gc(); c != '-' &amp;&amp; !isdigit(c); c = gc()); bool f = c == '-'; x = (f ? gc() : c) - '0'; for (c = gc(); isdigit(c); c = gc()) x = x * 10 + (c - '0'); if (f) x = -x; return *this; &#125; char *gs(char *x) &#123; for (c = gc(); !isgraph(c); c = gc()); for (*x++ = c, c = gc(); isgraph(c); *x++ = c, c = gc()); return *x = 0, x; &#125; IO &amp;operator &gt;&gt; (char *x) &#123; for (c = gc(); !isgraph(c); c = gc()); for (*x++ = c, c = gc(); isgraph(c); *x++ = c, c = gc()); return *x = 0, *this; &#125; IO &amp;operator &gt;&gt; (char &amp;x) &#123; for (x = gc(); !isgraph(x); x = gc()); return *this; &#125; template &lt;class T&gt; operator T () &#123; T x; *this &gt;&gt; x; return x; &#125; void pc(cchar x) &#123; if (z == b + LO) fbo-&gt;sputn(z = b, LO); *z++ = x; &#125; void fl() &#123; fbo-&gt;sputn(b, z - b); z = b; &#125; template &lt;class T&gt; IO &amp;operator &lt;&lt; (T x) &#123; if (x == 0) return pc('0'), *this; if (x &lt; 0) pc('-'), x = -x; char *j = r; for (T y; x; x = y) y = x / 10, *j++ = x - y * 10 + '0'; while (j != r) pc(*--j); return *this; &#125; IO &amp;operator &lt;&lt; (char *x) &#123; while (*x) pc(*x++); return *this; &#125; IO &amp;operator &lt;&lt; (cchar *x) &#123; while (*x) pc(*x++); return *this; &#125; IO &amp;operator &lt;&lt; (cchar x) &#123; return pc(x), *this; &#125;&#125;;IO&lt;1000000, 1000000&gt; io;cint N = 100003;int n;ll ret;inline ll fsum(cll x, cll y) &#123; return x + y;&#125;struct Node &#123; Node *lc, *rc; int len; ll sum, min, max, tgs, tga; // tgs goes first Node() &#123;&#125; Node(cll x) : lc(NULL), rc(NULL), len(1), sum(x), min(x), max(x), tgs(LLONG_MIN), tga(0) &#123;&#125; Node(Node *l, Node *r, cint le) : lc(l), rc(r), len(le), tgs(LLONG_MIN), tga(0) &#123; maintain(); &#125; void maintain() &#123; sum = lc-&gt;sum + rc-&gt;sum; min = std::min(lc-&gt;min, rc-&gt;min); max = std::max(lc-&gt;max, rc-&gt;max); &#125; void cover_s(cll x) &#123; sum = x * len; min = max = tgs = x; tga = 0; &#125; void cover_a(cll x) &#123; sum += x * len; min += x; max += x; tga += x; &#125; void push_down() &#123; if (tgs != LLONG_MIN) &#123; lc-&gt;cover_s(tgs); rc-&gt;cover_s(tgs); tgs = LLONG_MIN; &#125; if (tga) &#123; lc-&gt;cover_a(tga); rc-&gt;cover_a(tga); tga = 0; &#125; &#125;#define MODIFY_FUNC(func, coverrer) \ void func(cint ql, cint qr, cll x, cint l = 1, cint r = n) &#123; \ if (qr &lt; l || r &lt; ql) \ return; \ if (ql &lt;= l &amp;&amp; r &lt;= qr) \ return coverrer(x); \ push_down(); \ int mid = (l + r) &gt;&gt; 1; \ if (ql &lt;= mid) \ lc-&gt;func(ql, qr, x, l, mid); \ if (qr &gt; mid) \ rc-&gt;func(ql, qr, x, mid + 1, r); \ maintain(); \ &#125;#define QUERY_FUNC(func, attr, opt) \ void func(cint ql, cint qr, cint l = 1, cint r = n) &#123; \ if (qr &lt; l || r &lt; ql) \ return; \ if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; \ ret = opt(ret, attr); \ return; \ &#125; \ push_down(); \ int mid = (l + r) &gt;&gt; 1; \ if (ql &lt;= mid) \ lc-&gt;func(ql, qr, l, mid); \ if (qr &gt; mid) \ rc-&gt;func(ql, qr, mid + 1, r); \ &#125; MODIFY_FUNC(add, cover_a); MODIFY_FUNC(set, cover_s); QUERY_FUNC(qmin, min, std::min); QUERY_FUNC(qmax, max, std::max); QUERY_FUNC(qsum, sum, fsum);&#125; *segt;Node *build(cint l, cint r) &#123; static Node pool[N &lt;&lt; 1], *curr = pool; if (l == r) return new (curr++) Node((ll)io); int mid = (l + r) &gt;&gt; 1; Node *lc = build(l, mid); return new (curr++) Node(lc, build(mid + 1, r), r - l + 1);&#125;int main() &#123; int m; io &gt;&gt; n &gt;&gt; m; segt = build(1, n); char opt[6]; while (m--) &#123; int l, r; io &gt;&gt; opt &gt;&gt; l &gt;&gt; r; if (opt[0] == 's') &#123; if (opt[1] == 'u') ret = 0, segt-&gt;qsum(l, r), io &lt;&lt; ret daze; else segt-&gt;set(l, r, io); &#125; else if (opt[0] == 'm') &#123; if (opt[1] == 'i') ret = LLONG_MAX, segt-&gt;qmin(l, r); else ret = LLONG_MIN, segt-&gt;qmax(l, r); io &lt;&lt; ret daze; &#125; else segt-&gt;add(l, r, io); &#125;&#125;]]></content>
      <tags>
        <tag>线段树 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode配置]]></title>
    <url>%2F2018%2F12%2F23%2FVSCode%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[自己用的VSCode配置。 12345678&#123; &quot;workbench.colorTheme&quot;: &quot;Solarized Dark&quot;, &quot;editor.fontFamily&quot;: &quot;&apos;Fira Code&apos;, Consolas, &apos;Courier New&apos;, monospace&quot;, &quot;editor.fontLigatures&quot;: true, &quot;editor.fontSize&quot;: 16, &quot;C_Cpp.clang_format_style&quot;: &quot;&#123; BasedOnStyle: LLVM, IndentWidth: 4 &#125;&quot;, &quot;C_Cpp.clang_format_fallbackStyle&quot;: &quot;&#123; BasedOnStyle: LLVM, IndentWidth: 4 &#125;&quot;,&#125;]]></content>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见配置]]></title>
    <url>%2F2018%2F12%2F15%2FLinux%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Linux系统和软件配置。 Ubuntu更换软件源在/etc/apt/sources.list下加入软件源（18.04LTS） 1234deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse 配置archlinuxcn源在配置文件/etc/pacman.conf后添加 123[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 导入GPG key 1sudo pacman -Syyu &amp;&amp; sudo pacman -S archlinuxcn-keyring 配置官方镜像源更新镜像排名和数据源 12sudo pacman-mirrors -i -c China -m ranksudo pacman -Syy 更新archlinux签名 1pacman -S archlinux-keyring 安装输入法123sudo pacman -S fcitx-sogoupinyinsudo pacman -S fcitx-imsudo pacman -S fcitx-configtool 在配置文件~/.xprofile后添加 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 使用可视化界面调节输入法设置 1fcitx-configtool 修改grub修改配置文件/boot/grub/grub.cfg Zsh配置安装zsh shellsudo apt install zsh 安装oh-my-zsh 1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 更改默认shell 12sudo chsh -s /bin/zsh vozeosudo chsh -s /bin/zsh 在zsh配置文件~/.zshrc中修改 123agnostersudoalias vim=&apos;nvim&apos; 下载打包好的powerline字体 修改完以后刷新source ~/.zshrc Nvim配置安装Plug 1curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 修改nvim配置~/.config/nvim/init.vim 123456789101112131415161718192021call plug#begin()Plug &apos;vim-airline/vim-airline&apos;Plug &apos;vim-airline/vim-airline-themes&apos;Plug &apos;jiangmiao/auto-pairs&apos;call plug#end()let g:airline#extensions#tabline#enabled=1let g:airline_powerline_fonts=1set numberset rulerset mouse=aset history=1000set ignorecaseset autoindentset smartindentset shiftwidth=4set tabstop=4&quot;imap &#123;&lt;CR&gt; &#123;&lt;ESC&gt;o&#125;&lt;ESC&gt;Oautocmd FileType cpp map &lt;F4&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -O2 -Wall -Wshadow -o ./%&lt; &lt;CR&gt;autocmd FileType cpp map &lt;F5&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -O2 -Wall -Wshadow -o ./%&lt; &amp;&amp; ./%&lt; &lt;CR&gt;autocmd FileType cpp map &lt;F7&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -Og -g -Wall -Wshadow -o ./%&lt; &amp;&amp; gdb ./%&lt; &lt;CR&gt; 更新python-nvim 123sudo apt install python-pip python3-pippip install neovim --upgradepip3 install neovim --upgrade 函数名高亮在/usr/share/nvim/syntax/c.vim后添加 1234&quot;highlight Functionssyn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;[^()]*)(&quot;me=e-2syn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;\s*(&quot;me=e-1hi cFunctions gui=NONE cterm=bold ctermfg=blue 在终端使用代理安装sudo apt install proxychains在/etc/proxychains.conf最下方添加socks5 127.0.0.1 1080 Konsole配色（solarized改进版）前景：灰色#93a1a1背景：蓝黑#002b36颜色1：黑色#073642颜色2：红色#dc322f颜色3：绿色#859900颜色4：黄色#b58900颜色5：蓝色#268bd2颜色6：洋红#d33682颜色7：浅蓝#5ed5fd]]></content>
      <tags>
        <tag>linux 配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论基础]]></title>
    <url>%2F2018%2F08%2F19%2F%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数学博大精深。 最大公因数算术基本定理 任何一个大于$1$的正整数都能分解为有限个质数的乘积。 欧几里得算法原理：$\gcd(a,b)=\gcd(b,a \bmod b)$ 复杂度:$O(\log n)$。 代码实现：1234int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125; 更相减损术原理：$\gcd(a,b)=\gcd(b,a-b)$ 高精度取余不好做时可用这个代替，实现与欧几里得算法相似。 质数Eratosthenes筛法对于每一个质数，除了自己以外，它的倍数一定不是质数，需要筛去，留下的都是质数。 复杂度$O(n\log\log n)$。（不会证明） 代码实现：123456789101112int pri[N];bool vis[N];void Eratosthenes(int n)&#123; for (int i = 2; i * i &lt;= n; ++i) if (!vis[i]) for(int j = i + i; j &lt;= n; j += i) vis[i] = 1; for (int i = 2; i &lt;= n; i++) if(!vis[i]) pri[++cnt] = i;&#125; 欧拉筛线性筛法。对于每一个数从最小的质因数从小到大开始筛去，保证分解是唯一的，避免重复筛除。用途不仅仅是筛质数哟！ 复杂度$O(n)$。 代码实现：12345678910111213141516int cnt, pri[N];bool vis[N];void prime(int n)&#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) pri[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= n; j++) &#123; vis[j * pri[j]] = 1; if (i % pri[j] == 0) //说明有比pri[j]更小的质数已经筛过它了 break; &#125; &#125;&#125; 当$n&gt;5$时，质数总是出现在$6$的倍数的两侧，可以让$i$每次自增$6$进行优化。此外，当提问次数很大时，还可用$Miller-Rabin$算法进一步降低复杂度。 方程裴蜀定理 关于$x$和$y$的线性丢番图方程$ax+by=d$有解当且仅当$\gcd(a,b)|d$。 扩展欧几里得算法求出两个数的最大公因数，并求出方程$ax+by=\gcd(a,b)$的一组绝对值最小的整数解或判断它无解。 当我们用欧几里得算法求解最大公因数的最后一步， 即$a=\gcd(a,b),b=0$时， 方程$ax+by=\gcd(a,b)$的解为$x=1,y=0$， 即$$a’\times1+b’\times0=\gcd(a,b)$$ 对于每一个已知解的方程，设此时的两个数为$a’,b’$， 则有$a’x+b’y=\gcd(a,b)$， 此时的$a’,b’$时由上一步的$b,a\bmod b$计算得来， 即$a’=b,b’=a\mod b$， $$\Longrightarrow bx+(a\bmod b)y=\gcd(a,b)$$ $$\Longrightarrow bx+(a- \lfloor \frac{a}{b} \rfloor \times b)y=\gcd(a,b)$$ （$\lfloor \rfloor$为向下取整） $$\Longrightarrow ay+b(x- \lfloor \frac{a}{b} \rfloor y)=\gcd(a,b)$$ 设此时的解为$x’,y’$，则$x’=y,y’=x- \lfloor \frac{a}{b} \rfloor y$ 一层层向上递归可得原方程的解。 代码实现：1234567891011int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(a, b, y, x); y -= (a / b) * x; return d;&#125; 此时求出的解为$ax+by=\gcd(a,b)$的一组解$x_0,y_0$，若要求$ax+by=d(\gcd(a,b)|d)$的解， 设$c=\gcd(a,b)$，方程的通解为$$x=x_0\frac{d}{c}+k\frac{b}{c},y=y_0\frac{d}{c}-k\frac{a}{c}(k\in\mathbb{Z})$$ 一次同余方程一元一次同余方程$ax\equiv b\pmod m$ 转化为$ax+my=b$即可。 多元一次同余方程使用中国剩余定理或者多次$exgcd$。 中国剩余定理方程组$$\left\{\begin{aligned}x\equiv a_1\pmod {m_1} \\x\equiv a_2\pmod {m_2}\\……\\x\equiv a_n\pmod {m_n}\end{aligned}\right.$$ （其中$m$两两互质）的通解为$ \sum_{i=1}^{n}M_ia_it_i $，设$ M=\sum_{i=1}^{n} m_i $，其中$M_i=\frac{M}{m_i} $，$t_i$为$M_i$模$m_i$的乘法逆元。 证明：乘$M_i$则整除其他的$m$，乘$t_i$则整除$m_i$，乘$a_i$则模$m_i$为$a$。 扩展中国剩余定理模数$m$不是两两互质，此时扩展中国剩余定理不再适用。 考虑两个不定方程，可用$exgcd$求出他们的通解，将这两个方程转化为一个，模数变成他们的最小公倍数。进行n次即可。 快速幂快速求出$a^b\bmod p$。有递归和位运算两种实现，每次将指数$b$降低为$\frac{b}{2}$。快速乘同理。 复杂度$O(\log n)$。 代码实现：123456789101112int qpow(int a, int b, int p)&#123; int ans = 1; while(b) &#123; if(b &amp; 1) ans = (long long)ans * a % p; a = (long long)a * a % p; b &gt;&gt;= 1; &#125; return ans;&#125; 还有很多，待更。$\LaTeX$真是美妙的工具。]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次搭建博客]]></title>
    <url>%2F2018%2F08%2F19%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天新搭建了博客，把自己遇到的问题总结一下。 主要参考了网上的教程，后来又按照ouuan的博客重新搭了一遍。 切换到国内npm镜像1npm config set registry https://registry.npm.taobao.org 升级npm1.查看当前版本npm -v2.进行npm自动更新npm install npm@latest -g 升级node1.查看当前版本node -v2.清除缓存sudo npm cache clean -f3.安装node版本管理工具sudo npm install n -g4.升级到最新版本sudo n latest 安装Hexo安装并初始化Hexo 123npm install -g hexohexo initnpm install 将博客上传至GitHub生成SSH 1ssh-keygen 打开~/.ssh/id_rsa.pub向GitHub添加SSH key 输入命令 ssh -T git@github.com ，若出现 Hi yourname! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 表示 SSH 配置成功。 安装deployer 1npm install hexo-deployer-git --save 测试一下markdown1#include&lt;bits/stdc++.h&gt; 列表delete 分割线 引用 略略略 嘤嘤嘤 喵喵喵 咩咩咩 斜体table 1 2 3 哈哈 呜呜 略略 return 0;]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
