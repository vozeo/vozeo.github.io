<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[点分治]]></title>
    <url>%2F2019%2F05%2F18%2F%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[点分治是一种处理树上点对问题及其类似问题的方法。 主要用来处理树上带有边权的特定条件点对的计数和判定。主要思想是将所有路径分为过根节点和不过根节点的路径，每次统计过根节点的路径，再去递归地子树内统计其他路径。可以选树的重心作为根节点，这样每次递归后树的大小至少会减少一半，总共需要统计$O(\log n)$棵树。 主要有几个函数： findroot：找到根节点。通过树形dp，每次更新size，使得除去当前节点后剩余的最大的树最小，以前访问过的不再访问。 calculate：计算当前子树内产生的答案。常常是进行dfs，通过一个队列（栈）记录子树内所有的点到根节点的距离，再枚举点对或者扫描队列进行统计。且经常需要多次dfs来排除重复的解。 getdis：即dfs计算每个节点的dis。 dfs：主工作函数。找到根节点后从这里dfs计算距离，常常需要多次调用calculate排除重复解。]]></content>
      <tags>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树链剖分]]></title>
    <url>%2F2019%2F05%2F18%2F%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[树链剖分是一种比较暴力的数据结构。原理是把树剖分成链，再用数据结构维护每一条链（一般是线段树）。可以快速查询和修改树上路径（点权、边权）等问题。习惯上树链剖分都指轻重链剖分。 主要步骤：通过两次dfs把树剖分为链，再用线段树维护，查询的时候$O(\log n)$向上跳，再每次$O(\log n)$查询。 dfs1：确定每个点的depth、size、father、son（重儿子）。 dfs2：确定每个点的dfn、top（链顶所在的点）。先搜索重儿子，再搜轻儿子。 如果没有父亲或者父亲的重儿子不是自己，top就是自己，否则就是父亲的top。 这样搜索能保证每个点都在一条重链上，且每条重链在线段树上对应一段连续的区间，且每个子树也对应一段连续的区间。 线段树建树：建树前先把权值放到每个点的dfn的位置，用dfn建树。 查询：从两个点向上跳，每次找到深度较深的点，向上跳一条链，统计这一条链上的数据，在把当前点跳到链顶的父亲，直到两个点在同一条链上，最后区间查询两点即可。修改同理。复杂度$O(\log n)$。 常见的套路就是和点权有关，且有修改，每次修改一条路径或者一颗子树，查询一条路径或者一颗子树的点权。]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对拍]]></title>
    <url>%2F2019%2F04%2F20%2F%E5%AF%B9%E6%8B%8D%2F</url>
    <content type="text"><![CDATA[Linux下的对拍代码。12345678910111213141516#!/bin/bashfile="problem"# for i in `seq 1 20`while truedo ./make &gt;$file$i.in time ./$file &lt;$file$i.in &gt;$file$i.out ./$file-force &lt;$file.in &gt;$file.ans if diff $file$i.out $file$i.ans then echo "AC" else echo "WA" exit 0 fidone]]></content>
      <tags>
        <tag>对拍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[splay学习笔记]]></title>
    <url>%2F2019%2F04%2F07%2Fsplay%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[splay大法好。 颓了很长时间，最近什么都没做。算是迷失了方向，又找到了方向吧。曾对这个世界感到失望，但还是要有希望，有理想和目标。继续加油吧。 遇见了，不后悔遇见就好。 颓废有用的话，也就不会这么难受了。 一定要有目标。不要管目标能不能达成，只要知道自己努力了就好。 到头来回忆起的，是那段艰苦的岁月，而不是最终的瞬时的胜利。 那些努力追求的东西，都是为了某一个初心。不能放弃初心。 人要成长的啊。想想自己要是荒废了时间，那多亏啊。 累的睡着，睡到天亮。太阳照在身上的时候，感觉很幸福。 要坚定这种幸福一直都在。发现世界还是这么美好的时候，自己是没有理由崩溃的。 ——壮壮 那么，让我们来看splay吧。 splay是一种平衡树。在权值上满足二叉排序树的性质，即左儿子小于自己，右儿子大于自己。通过旋转保持平衡。不像treap的一个权值还满足堆的性质，这里只有权值的大小。 splay是一种自适应的数据结构。就是说，树的结构会随着操作的不同而变得更易于操作。比如说，如果插入的次数很多，插入就会变得更快。如果修改的速度很多，修改的速度就会变快。听起来非常神奇，可能需要进一步理解。 splay的速度很慢，通过势能分析可以说明，大部分操作是均摊$O(\log n)$的。但事实上，跑起来比大多数的平衡树都慢。不过splay的优势是非常灵活，可以支持很多操作，但写起来很长。其实除了LCT，其他的操作都是可以替代的。不过它依然是非常重要的数据结构，而且出题人也不会去卡splay，写LCT也要用到，当然要好好学啦。 这里给出指针的版本。有时候一些数据结构也可以用数组写，还是都掌握比较好。 核心操作Node的定义Node中存了当前节点的权值、子树大小、这个数字出现的次数和父亲指针、儿子指针。 由于很多操作都是直接针对节点的，因此在Node中有很多函数。不过有简单的几个方法。 maintain：更新子树大小。relation：和父亲的关系。0表示左儿子或不存在父亲，1表示右儿子。 12345678910111213struct Node *root;struct Node &#123; int v, cnt, siz; Node ch[2], *fa; Node() &#123;&#125; Node(int x, Node *f) : v(x), cnt(1), siz(1), fa(f) &#123;&#125; void maintain() &#123; siz = cnt + (ch[0] ? ch[0]-&gt;siz : 0) + (ch[1] ? ch[1]-&gt;siz : 0); &#125; void rel() &#123; return fa ? fa-&gt;ch[1] == this : 0; &#125;&#125; rotate旋转是splay最重要、最基本的操作了。也是保证splay复杂度正确，维护树形态的必要操作。 目的是改变父子关系，调换父子的位置，把当前节点上移一位。 改变树的形态的基础上，保证以下两点： 树的中序遍历。即父子的大小关系和整个序列的值。 受影响的节点的size都依然有效。 操作步骤： 将自身连接到祖父上，替代父亲； 将和父亲关系相反的孩子与父亲连接，替代自身； 将父亲连接到上一步的孩子的位置； 如果此时自身为根，则更新root。 kyr1no学长写了神奇的link函数，使代码变得更简单。 12345678910111213141516void link(Node *o, Node *f, int r) &#123; if (o) o-&gt;fa = f; if (f) f-&gt;ch[r] = o;&#125;void rotate &#123; int r = rel(); Node f = *fa; link(this, f-&gt;fa, f-&gt;rel()); link(ch[r ^ 1], f, r); link(f, this, r ^ 1); f-&gt;maintain(); maintain(); if (!fa) root = this;&#125; splay顾名思义，这也是splay的核心函数，也被称为伸展操作。 目的是把当前节点旋转到根，维护整棵树的形态。 但是直接死循环判断是不可取的。一条链旋转以后还是一条链，无法保证复杂度。因此采取一些方法让其更好的旋转。 发现了一张图片可以说明： 操作步骤： 如果父亲是目标节点，直接旋转； 如果父亲与祖父的关系和自己与父亲的关系相同，就先旋转父亲，再旋转自身； 否则就将自身旋转两次。 123456789void splay(Node *tar = NULL) &#123; // 目标节点的父亲节点 while (fa != tar) &#123; if (fa-&gt;fa == tar) rotate(); else if (rel() == fa-&gt;rel()) fa-&gt;rotate(), rotate(); else rotate(), rotate(); &#125;&#125; 基本操作splay支持的操作很多，这里主要是平衡树的最基本操作。 insert在树中插入一个数字。 找到这个数的位置，如果这个数字出现过，就加上$1$，否则就新建这个节点。 有双指针的迭代版本和递归版，递归版的稍微快一点。可以省略沿途的maintain，因为最后splay的时候会按照原路maintain，直到root。 双指针迭代版：123456789101112131415Node *ins(int x) &#123; Node **o = &amp;root, *fa = NULL; while (*o &amp;&amp; (*o)-&gt;v != x) &#123; fa = *o; //++fa-&gt;siz; o = &amp;fa-&gt;ch[x &gt; fa-&gt;v]; // *** &#125; if (*o) ++(*o)-&gt;cnt; //++(*o)-&gt;siz; else *o = new (tcur++) Node(fa, x); (*o)-&gt;splay(); return root;&#125; 递归版：12345678Node ins(Node *&amp;o, Node *f, int x) &#123; if (!o) o = new (tcur++) Node(f, x); //++o-&gt;siz; if (o-&gt;v == x) return ++o-&gt;cnt, o; return ins(o-&gt;ch[x &gt; o-&gt;v], o, x);&#125; delete(erase)支持区间删除和单点删除。 把左端点的前驱splay到根，再把右端点的后继splay到根的右子树，再删除右端点后继的左儿子就好啦。实际上就包括了左端点到右端点的全部区间。和treap还是很像的。 如果是单点删除，要注意是否多次出现，如果多次出现就把出现次数减1。 12345678910111213void del(Node *o) &#123; Node *p = o-&gt;pre(), *s = o-&gt;suc(); p-&gt;splay(), s-&gt;splay(p); // *** if (o-&gt;cnt &gt; 1) --o-&gt;cnt, --o-&gt;siz; else s-&gt;ch[0] = NULL; s-&gt;upd(), p-&gt;upd();&#125;void del(int x) &#123; Node *o = find(x); if (o) del(o);&#125; build和线段树的build差不多，等做到的时候再写吧。 find在树中找一个数字。如果找到记得splay。 1234567Node *find(int x) &#123; Node *o = root; while (o &amp;&amp; o-&gt;v != x) o = o-&gt;ch[x &gt; o-&gt;v]; if (o) o-&gt;splay(); return o;&#125; rank由于哨兵节点的存在，只需要splay后返回左子树的值就好啦。要是改成查询某一个数字的rank的话，和predecessor、successor都一样啦。 节点内部：123int rnk() &#123; return ch[0] ? ch[0]-&gt;siz : 0;&#125; 节点外部：12345678int rnk(int x) &#123; Node *o = find(x); if (o) return o-&gt;rnk(); o = ins(x); int ans = o-&gt;rnk(); del(o); return ans;&#125; kth(select)查询第$k$大。很多地方写的是select。就是在树上二分一下。 注意由于哨兵节点的存在，只需要左子树的大小等于$k$时，这个数即为第$k$大。 123456789101112int kth(int k) &#123; Node *o = root; while (true) &#123; if (o-&gt;rnk() &gt; k) o = o-&gt;ch[0]; else if (o-&gt;rnk() + o-&gt;cnt &lt;= k) k -= o-&gt;rnk() + o-&gt;cnt, o = o-&gt;ch[1]; // *** else break; &#125; o-&gt;splay(); // *** return o-&gt;v;&#125; predecessor有两种实现，分别是找到前驱节点和找到前一个数字。前驱节点当然是比它小的最大值。先splay到根，再取左子树的最大值就好啦。一般调用的时候都会先find，而在find的时候就已经splay过了，这里可以不重复splay。 节点版本：1234567Node *pre(Node *o) &#123; //o-&gt;splay(); o = o-&gt;ch[0]; while (o-&gt;ch[1]) o = o-&gt;ch[1]; return o;&#125; 数字版本：12345678int pre(int x) &#123; Node *o = find(x); if (o) return o-&gt;pre()-&gt;v; o = ins(x); int ans = o-&gt;pre()-&gt;v; del(o); return ans;&#125; successor和pred一样啦。找右子树的最小值就好啦。 节点版本：1234567Node *suc(Node *o) &#123; //o-&gt;splay(); o = o-&gt;ch[1]; while (o-&gt;ch[0]) o = o-&gt;ch[0]; return o;&#125; 数字版本：12345678int suc(int x) &#123; Node *o = find(x); if (o) return o-&gt;suc()-&gt;v; o = ins(x); int ans = o-&gt;suc()-&gt;v; del(o); return ans;&#125; 其实可以和pred合并成一个函数。 进阶操作区间反转什么的，非常多。做到再写吧。 完整代码P3369普通平衡树。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;const int N = 1e5 + 5;struct Node *root;struct Node &#123; Node *fa, *ch[2]; int v, cnt, siz; Node() &#123;&#125; Node(Node *f, int x) : fa(f), v(x), cnt(1), siz(1) &#123;&#125; void upd() &#123; siz = cnt + (ch[0] ? ch[0]-&gt;siz : 0) + (ch[1] ? ch[1]-&gt;siz : 0); &#125; int rel() &#123; return fa ? fa-&gt;ch[1] == this : 0; &#125; void link(Node *o, Node *f, int r) &#123; if (o) o-&gt;fa = f; if (f) f-&gt;ch[r] = o; &#125; void rot() &#123; Node *f = fa; int r = rel(); link(this, f-&gt;fa, f-&gt;rel()); link(ch[r ^ 1], f, r); link(f, this, r ^ 1); f-&gt;upd(), upd(); if (!fa) root = this; &#125; void splay(Node *tar = NULL) &#123; while (fa != tar) &#123; if (fa-&gt;fa == tar) rot(); else if (rel() == fa-&gt;rel()) fa-&gt;rot(), rot(); else rot(), rot(); &#125; &#125; int rnk() &#123; return ch[0] ? ch[0]-&gt;siz : 0; &#125; Node *pre() &#123; Node *o = ch[0]; while (o-&gt;ch[1]) o = o-&gt;ch[1]; return o; &#125; Node *suc() &#123; Node *o = ch[1]; while (o-&gt;ch[0]) o = o-&gt;ch[0]; return o; &#125;&#125; tpool[N], *tcur = tpool;Node *find(int x) &#123; Node *o = root; while (o &amp;&amp; o-&gt;v != x) o = o-&gt;ch[x &gt; o-&gt;v]; if (o) o-&gt;splay(); // *** return o;&#125;Node *ins(Node *&amp;o, Node *f, int x) &#123; if (!o) return o = new (tcur++) Node(f, x); if (o-&gt;v == x) return ++o-&gt;cnt, o; return ins(o-&gt;ch[x &gt; o-&gt;v], o, x);&#125;Node *ins(int x) &#123; Node *o = ins(root, NULL, x); o-&gt;splay(); return o;&#125;void del(Node *o) &#123; Node *p = o-&gt;pre(), *s = o-&gt;suc(); p-&gt;splay(), s-&gt;splay(p); // *** if (o-&gt;cnt &gt; 1) --o-&gt;cnt, --o-&gt;siz; else s-&gt;ch[0] = NULL; s-&gt;upd(), p-&gt;upd();&#125;void del(int x) &#123; Node *o = find(x); if (o) del(o);&#125;int rnk(int x) &#123; Node *o = find(x); if (o) return o-&gt;rnk(); o = ins(x); int ans = o-&gt;rnk(); del(o); return ans;&#125;int kth(int k) &#123; Node *o = root; while (true) &#123; if (k &lt; o-&gt;rnk()) o = o-&gt;ch[0]; else if (k &gt;= o-&gt;rnk() + o-&gt;cnt) k -= o-&gt;rnk() + o-&gt;cnt, o = o-&gt;ch[1]; else break; &#125; o-&gt;splay(); return o-&gt;v;&#125;int pre(int x) &#123; Node *o = find(x); if (o) return o-&gt;pre()-&gt;v; o = ins(x); int ans = o-&gt;pre()-&gt;v; del(o); return ans;&#125;int suc(int x) &#123; Node *o = find(x); if (o) return o-&gt;suc()-&gt;v; o = ins(x); int ans = o-&gt;suc()-&gt;v; del(o); return ans;&#125;void init() &#123; ins(INT_MAX); ins(INT_MIN);&#125;int main() &#123; int n, op, x; init(); scanf("%d", &amp;n); while (n--) &#123; scanf("%d%d", &amp;op, &amp;x); switch(op) &#123; case 1: ins(x);break; case 2: del(x);break; case 3: printf("%d\n", rnk(x));break; case 4: printf("%d\n", kth(x));break; case 5: printf("%d\n", pre(x));break; case 6: printf("%d\n", suc(x));break; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>splay</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[珂朵莉树学习笔记]]></title>
    <url>%2F2019%2F04%2F01%2F%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[珂朵莉树是一种暴力数据结构，代码较短，原理简单。适用于骗分和暴力对拍。 适用范围 含有区间赋值操作。 操作随机或者区间赋值操作较多。 维护区间高次幂。 主要原理把连续一段相同的值合并成一块，用set维护这些块。 随机数据下期望复杂度$O(m\log n)$（$m$为操作数，$n$为序列内数字个数）。 基本操作Node123456789struct Node &#123; int l, r; mutable int v; Node() &#123;&#125; Node(int x, int y = -1, int z = 0) : l(x), r(y), v(z) &#123;&#125; bool operator &lt; (const Node &amp;rhs) const &#123; return l &lt; rhs.l; &#125;&#125;; 注意：用iterator修改值时，该值必须为mutable形式。默认是只读，不这样写不能编译通过。 split把一个块分裂为两块。123456789101112set&lt;Node&gt; s;typedef set&lt;Node&gt;::iterator Iter;Iter split(int pos) &#123; Iter it = s.lower_bound(Node(pos)); if (it != s.end() &amp;&amp; it-&gt;l == pos) // *** return it; --it; int l = it-&gt;l, r = it-&gt;r, v = it-&gt;v; // *** s.erase(it); s.insert(Node(l, pos - 1, v)); return s.insert(Node(pos, r, v)).first;&#125; 默认的insert是std::pair&lt;iterator,bool&gt; insert(const value_type &amp;value)，这里用它的返回值first。 注意： if内的先后顺序，颠倒后会访问空指针出错。 后面的erase和insert会使当前的it指针失效，指向其他地方，所以要先记下来这些值。 函数内含有erase，可能会使其他iterator失效，调用的时候应注意这种情况。 assign把连续相同数字的区间合并成一块。是珂朵莉在随机数据下复杂度的保证。 在随机数据下，每次合并的期望长度为$\frac{n}{3}$。 12345void assign(int l, int r, int v) &#123; Iter itr = split(r + 1), itl = split(l); // *** s.erase(itl, itr); s.insert(Node(l, r, v));&#125; void erase(iterator first, iterator last)可删除[first,last)区间。 注意：取区间的时候应当先取后面再取前面，否则取完前面后，后面的指针会发生变化。 其他操作全是暴力，具体见代码。 题目CF896C。也是珂朵莉树的来源。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i_, s_, t_) for (int i_ = (s_); i_ &lt;= (t_); ++i_)typedef long long ll;const int N = 1e5 + 5, P = 1e9 + 7;int a[N];ll seed;ll qpow(ll o, int x, int mod) &#123; ll res = 1; o %= mod; // *** for (; x; o = o * o % mod, x &gt;&gt;= 1) if (x &amp; 1) res = res * o % mod; return res;&#125;struct Node &#123; int l, r; mutable ll v; Node() &#123;&#125; Node(int x, int y = -1, ll z = 0) : l(x), r(y), v(z) &#123;&#125; bool operator &lt; (const Node &amp;rhs) const &#123; return l &lt; rhs.l; &#125;&#125;;typedef set&lt;Node&gt;::iterator Iter;set&lt;Node&gt; s;Iter split(int p) &#123; Iter it = s.lower_bound(Node(p)); if (it != s.end() &amp;&amp; it-&gt;l == p) return it; it--; // *** int l = it-&gt;l, r = it-&gt;r; ll val = it-&gt;v; s.erase(it); s.insert(Node(l, p - 1, val)); return s.insert(Node(p, r, val)).first;&#125;void assign(int l, int r, ll v = 0) &#123; Iter itr = split(r + 1), itl = split(l); s.erase(itl, itr); s.insert(Node(l, r, v));&#125;void add(int l, int r, int val) &#123; Iter itr = split(r + 1), itl = split(l); for (; itl != itr; ++itl) itl-&gt;v += val;&#125;ll kth(int l, int r, int k) &#123; vector&lt;pair&lt;ll, int&gt; &gt; t; Iter itr = split(r + 1), itl = split(l); t.clear(); for (; itl != itr; ++itl) t.push_back(make_pair(itl-&gt;v, itl-&gt;r - itl-&gt;l + 1)); // *** sort(t.begin(), t.end()); /* for (Iter it = t.begin(); it != t.end(); ++it) &#123; */ for (vector&lt;pair&lt;ll, int&gt; &gt;::iterator it = t.begin(); it != t.end(); ++it) &#123; k -= it-&gt;second; if (k &lt;= 0) return it-&gt;first; &#125; return -1;&#125;ll sum(int l, int r, int x, int mod) &#123; Iter itr = split(r + 1), itl = split(l); ll ans = 0; for (; itl != itr; ++itl) ans = (ans + 1ll * (itl-&gt;r - itl-&gt;l + 1) * qpow(itl-&gt;v, x, mod) % mod) % mod; return ans;&#125;int rnd() &#123; ll ret = seed; seed = (seed * 7 + 13) % P; return ret;&#125;int main() &#123; //freopen("CF896C.out", "w", stdout); int n, m, vmax, op, l, r, x, y = 0; scanf("%d%d%lld%d", &amp;n, &amp;m, &amp;seed, &amp;vmax); rep (i, 1, n) &#123; a[i] = rnd() % vmax + 1; s.insert(Node(i, i, a[i])); &#125; s.insert(Node(n + 1, n + 1, 0)); rep (i, 1, m) &#123; op = rnd() % 4 + 1; l = rnd() % n + 1; r = rnd() % n + 1; if (l &gt; r) swap(l, r); if (op == 3) x = rnd() % (r - l + 1) + 1; else x = rnd() % vmax + 1; if (op == 4) y = rnd() % vmax + 1; if (op == 1) add(l, r, x); else if (op == 2) assign(l, r, x); else if (op == 3) printf("%lld\n", kth(l, r, x)); else printf("%lld\n", sum(l, r, x, y)); &#125;&#125; 再放一些其他能用珂朵莉树的题。 CF343D Water Tree P2572 [SCOI2010]序列操作 P4344 [SHOI2015]脑洞治疗仪 CF915E Physical Education Lessons P2787 语文1（chin1）- 理理思维 P4979 矿洞：坍塌 目前来看，大多数出题人都没有刻意去卡珂朵莉树，但是大部分情况下，由于数据不是随机，复杂度都是错的。 要谨慎使用。 2019.5.5更新： P5350序列。 标算是珂朵莉树。这道题有copy和swap操作，会在其中删除一部分，再插入一部分。在右端点$r$已经被删除的情况下，如果下一次还要$split(r)$，就会产生类似于$[r, r - 1]$的错误区间，会对答案产生影响。 解决方法：先取小再取大；或者在出现这种情况的时候特判一下。因为已经$split$过右端点，只需要判断是否小于等于它就好，不需要比较指针了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;bits/stdc++.h&gt;using namespace std;#define rep(i_, s_, t_) for (int i_ = (s_); i_ &lt;= (t_); ++i_)typedef long long ll;const int N = 3e5 + 5, P = 1e9 + 7;struct Node &#123; int l, r; mutable ll v; Node() &#123;&#125; Node(int x, int y = -1, ll z = 0) : l(x), r(y), v(z) &#123;&#125; bool operator &lt; (const Node &amp;rhs) const &#123; return l &lt; rhs.l; &#125;&#125; q[N], *top;typedef set&lt;Node&gt;::iterator Iter;set&lt;Node&gt; s;Iter split(int p) &#123; Iter it = s.lower_bound(Node(p)); if (it != s.end() &amp;&amp; it-&gt;l == p) return it; --it; int l = it-&gt;l, r = it-&gt;r; ll val = it-&gt;v; s.erase(it); s.insert(Node(l, p - 1, val)); return s.insert(Node(p, r, val)).first;&#125;void assign(int l, int r, ll v) &#123; Iter itr = split(r + 1), itl = split(l); s.erase(itl, itr); s.insert(Node(l, r, v));&#125;void add(int l, int r, int val) &#123; Iter itr = split(r + 1), itl = split(l); for (; itl != itr; ++itl) itl-&gt;v = (itl-&gt;v + val) % P;&#125;ll sum(int l, int r) &#123; Iter itr = split(r + 1), itl = split(l); ll ans = 0; for (; itl != itr; ++itl) ans = (ans + 1ll * (itl-&gt;r - itl-&gt;l + 1) * itl-&gt;v % P) % P; return ans;&#125;void copy(int l1, int r1, int l2, int r2) &#123; Iter itr2 = split(r2 + 1), itl2 = split(l2); s.erase(itl2, itr2); Iter itr1 = split(r1 + 1), itl1 = split(l1); int t = l2 - l1; for (; itl1 != itr1; ++itl1) s.insert(Node(itl1-&gt;l + t, itl1-&gt;r + t, itl1-&gt;v));&#125;void swp(int l1, int r1, int l2, int r2) &#123; int t = l2 - l1; top = q; Iter itr2 = split(r2 + 1), itl2 = split(l2), it = itl2; for (; it != itr2; ++it) *(++top) = Node(it-&gt;l - t, it-&gt;r - t, it-&gt;v); s.erase(itl2, itr2); Iter itr1 = split(r1 + 1), itl1 = split(l1); it = itl1; for (; it != itr1; ++it) s.insert(Node(it-&gt;l + t, it-&gt;r + t, it-&gt;v)); s.erase(itl1, itr1); while (top &gt; q) s.insert(*(top--));&#125;void rev(int l, int r) &#123; int t = l + r; Iter itr = split(r + 1), itl = split(l), it = itl; top = q; for (; it != itr; ++it) *(++top) = *it; s.erase(itl, itr); while (top &gt; q) s.insert(Node(t - top-&gt;r, t - top-&gt;l, top-&gt;v)), --top;&#125;char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf;#define getc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++)template&lt;typename T&gt;void read(T &amp;x) &#123; char ch; while (!isdigit(ch = getc())); for (x = ch - '0'; isdigit(ch = getc()); x = x * 10 + ch - '0');&#125;int main() &#123; freopen("test.in", "r", stdin); int n, m, op, l, r, x, y; read(n), read(m); s.insert(Node(n + 1, n + 1, 0)); rep (i, 1, n) read(x), s.insert(Node(i, i, x)); rep (i, 1, m) &#123; read(op), read(l), read(r); if (op == 1) printf("%lld\n", sum(l, r)); else if (op == 2) read(x), assign(l, r, x); else if (op == 3) read(x), add(l, r, x); else if (op == 4) read(x), read(y), copy(l, r, x, y); else if (op == 5) read(x), read(y), swp(l, r, x, y); else rev(l, r); &#125; Iter itr = split(n + 1), itl = split(1); for(; itl != itr; ++itl) rep (i, itl-&gt;l, itl-&gt;r) printf("%lld ", itl-&gt;v % P); puts("");&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整除分块]]></title>
    <url>%2F2019%2F03%2F25%2F%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[最近几天在学数论。发现有很多小技巧，比如一些式子的推导变形以及求和。整数分块就是一个小的求和技巧。 大神们的博客讲到在一些数论题里，经常有这样的式子： $$\sum_{i = 1}^n \left \lfloor \frac{n}{i} \right \rfloor$$ 如果用朴素方法，需要$O(n)$的复杂度。 但是可以注意到，由于下取整符号的存在，右边的值只可能有$\sqrt n$种取值，这启发我们用分块的思想，在$O(\sqrt n)$的时间内算出来。 通过打表发现，取值为$\left \lfloor \frac{n}{i} \right \rfloor$的块的右边界为$\frac{n}{\lfloor \frac{n}{i} \rfloor}$，于是就能算出来啦。 此处应该有一个证明。 12345for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = n / (n / l); sum += (r - l + 1) * (n / l); // something else&#125; 有两道题:「CQOI2007」余数求和，Calculating]]></content>
      <tags>
        <tag>数论</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学军培训记录总结]]></title>
    <url>%2F2019%2F03%2F18%2F%E5%B8%B8%E5%B7%9E%E5%9F%B9%E8%AE%AD%2F</url>
    <content type="text"><![CDATA[去学军中学培训了两个星期，感觉自己水平太差了。而且消耗在其他地方的时间太多，OI学的太少。 而且消耗在其他地方的时间太多，OI学的太少。回来以后，把这次去培训做的一些题总结一下，可能不太全面，因为很多题我水平太差，连讲解都听不懂。并给自己一个未来的计划。今年的自招政策要改，可能降不了多少分了，不过既然选择了OI，就不要让自己后悔，还是努力一点吧。 用E表示考试的编号，T表示题号。 E18T1 求$$\sum_{i=1}^n \sum_{j=1}^n S_{i,j} \times F_j \times P_j$$其中，$F$是错位排列数，$P$是圆排列数，$S$是第二类斯特林数。答案对$998244353$取模。 $n \le 100000$ 圆排列和错位排列都能$O(n)$求出来，但是斯特林数用朴素的方法只能$O(n^2)$递推，所以要先用二项式反演求出通项，再用NTT求出。 原式可化为：$$\sum\limits_{i=1}^nF_i\cdot (i-1)!\sum\limits_{j=0}^i \frac {(-1)^j} {j!}\cdot \frac {1} {(i-j)!} \sum\limits_{k=1}^n(i-j)^k$$ 设$f(x)=\frac{(-1)^x}{x!}$，$g(x)=\frac{1}{x!} \sum\limits_{i=1}^nx^i=\frac {x^{n+1}-1}{x!(x-1)}$，原式就是: $$\sum\limits_{i=1}^nF_i\cdot (i-1)!\sum\limits_{j=0}^if(j)g(i-j)$$ 后半部分是一个卷积，用NTT完成就好啦。 小结公式太难打了。 二项式反演不会，斯特林数递推式看不出来，NTT不会。 对于求和式，想到求出通项后求解，求出通项以后往往能用NTT优化，且模数也已经暗示了可以用NTT。 在和式的化简上，注意能不能用运算律调换顺序。这道题是扩大了求和的范围，把值为0的地方也加进来，简化了运算。 T2用Lucas定理证明了结论，然后用子集DP，即枚举所有子集转移。但是这样做复杂度很高，而且这道题卡空间，所以需要分两部分考虑。需要用到快速莫比乌斯变换快速求子集和。 小结和kyr1no学长出的那道题一样，$n$为奇数即$n \mod 2 = 1$，然后用lucas定理证明。想不到奇数的性质和lucas定理。 子集dp没学过。 T3写出$\varphi$函数的通项，把询问排序，用树状数组维护$\frac{p_i - 1}{p_i}$的积，每次直接回答。 小结和HH的项链那道题很像，都是把询问排序，树状数组维护一个区间内的信息，记录上一个出现的位置。 对于没有修改的询问，可以考虑把询问离线后排序，类似莫队算法和cdq分治。 要想到对于值域开线段树或者树状数组，这样可以把顺序的区间改为值的区间，有时候会很有效果。 总结对于$\varphi$函数和斯特林数，都把他们转化为了通项或者计算式，也应该想到把复杂的式子和计算转化为基本的运算，求出通项，再用数据结构或者类似FFT去优化。 学一个东西就要学透，如果急功近利一知半解，用的时候才发现自己什么都不会，就损失惨重了。 只有Day1的，咕咕咕……]]></content>
      <tags>
        <tag>培训</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OnlineJudge]]></title>
    <url>%2F2019%2F02%2F21%2FOnlineJudge%2F</url>
    <content type="text"><![CDATA[最近搭建了一个基于syzoj的OJ，把遇到的问题总结一下。 临时地址：http://39.105.15.76/ 搭建教程在这里，已经写的很清楚啦。 数据库需要输入密码的时候可以直接按回车跳过，否则需要输入mysql -p登录。 上传数据遇到413错误是因为nginx上传限制太小，修改配置文件即可。 出现错误重启一下服务就好了。 123systemctl restart syzoj-websystemctl restart syzoj-judge-daemonsystemctl restart syzoj-judge-runner 通过管理上传数据包出现403错误，安装p7zip-full即可解决。 1apt install p7zip-full 定时更新，按照Wiki的提示安装软件 12git statusgit pull]]></content>
      <tags>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ刷题表]]></title>
    <url>%2F2019%2F02%2F12%2FBZOJ%E5%88%B7%E9%A2%98%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[从网上转的BZOJ刷题列表。 难度0 题号 算法 思想难度 实现难度 总难度 推荐指数 1214 Ruby 0 0 0 10 3816 Ruby 0 0 0 10 1000 可持久化动态仙人掌剖分 1 1 2 10 2462 输出10个1 6 3 9 1 2463 小学奥数 10 2 12 2 1192 找规律/二分图 9 5 14 9 难度1 题号 算法 思想难度 实现难度 总难度 推荐指数 2659 数学 20 7 27 2 1968 枚举 15 13 28 2 2761 去重 12 18 30 6 3767 高精度A+B 10 20 30 2 1432 找规律 27 5 32 3 3098 随机卡HASH 23 10 33 2 1800 统计 20 16 36 3 1218 枚举 20 17 37 2 4001 找规律 28 9 37 3 2760 字符串处理 12 26 38 1 1088 DP/判断 22 17 39 6 1034 贪心 24 16 40 6 1207 DP 23 17 40 2 2748 DP 21 19 40 4 4302 分类讨论 29 11 40 1083 最小生成树 17 25 42 9 2563 转换后排序 27 15 42 7 3097 构造卡HASH 27 15 42 2 1022 简单博弈 30 13 43 3 2465 贪心 25 20 45 4 2122 暴力 28 18 46 2 1197 DP 31 19 50 2 1295 搜索 20 30 50 5 1821 最小生成树 25 25 50 4 难度2 题号 算法 思想难度 实现难度 总难度 推荐指数 2134 期望DP 30 20 50 4 1876 高精求GCD 18 33 51 2 2173 找规律 37 14 51 3 2208 暴力 23 28 51 2 1258 找规律 33 19 52 2 2005 数学 30 22 52 6 2429 最小生成树 23 29 52 3 2464 最短路 21 31 52 2 1028 枚举 26 27 53 4 2222 打表+手算 39 14 53 1 2456 脑补 34 19 53 6 4300 DP+单调转移 30 23 53 1008 数学分析+快速幂 27 27 54 7 1413 博弈 39 15 54 4 4368 贪心 31 23 54 1012 树状数组/线段树/RMQ 24 31 55 3 1228 博弈论SG函数 40 15 55 3 1489 DP 32 23 55 5 1607 线性筛因数 27 28 55 6 1050 并查集 27 29 56 8 1053 搜索 27 29 56 4 1261 DP 31 25 56 6 1303 前缀和 33 23 56 8 1569 DP 28 28 56 4 1970 暴力+高精 25 31 56 1 2241 暴力 28 28 56 2 1002 递推+高精度 32 25 57 2 1024 搜索 29 28 57 4 1054 BFS 27 30 57 5 1059 二分图 27 30 57 9 1191 二分图 27 30 57 9 1260 DP 32 25 57 6 1263 贪心+高精度 29 28 57 5 1816 二分 31 26 57 6 1854 二分图 27 30 57 6 1967 Floodfill最短路/贪心Cheat 42 15 57 1 3505 数学 29 28 57 4 4247 背包DP 31 26 57 1206 堆 27 31 58 3 1296 DP 33 25 58 6 1485 卡特兰数 29 29 58 3 1856 卡特兰数 29 29 58 3 2457 贪心 33 25 58 5 2467 找规律 37 21 58 3 2764 DP+高精度 26 32 58 2 1045&amp;3293 数学求中位数 33 25 58 5 1013 高斯消元 28 31 59 4 1025 DP 32 27 59 5 1078 模拟斜堆 31 28 59 4 1265 高精度 29 30 59 2 1433 二分图 29 30 59 4 1505 贪心 35 24 59 5 2048 数学 39 20 59 3 2156 最短路 29 30 59 2 3108 乱搞 36 23 59 4 3214 字符串处理 24 35 59 2 3668 进制乱搞 27 32 59 6 4195 离散化+并查集 28 31 59 4 1019 DP 35 25 60 3 1055 DP 33 27 60 6 1452 三维树状数组 27 33 60 3 1509 树上最长链 30 30 60 6 1867 DP 32 28 60 5 1965 快速幂+快速乘 30 30 60 7 2435 BFS 30 30 60 5 2705 欧拉函数 30 30 60 6 2783 树上倍增 30 30 60 6 3210 坐标转化 33 27 60 5 1015 并查集 32 29 61 8 1036 树链剖分/动态树 26 35 61 10 1047 二维RMQ 27 34 61 5 1084 DP 33 28 61 7 1213 二分+高精 25 36 61 1 3106 DP 31 30 61 5 3142 数学 36 25 61 5 3613 二分+贪心 33 28 61 4 1026 数位DP 31 31 62 6 1079 记忆化搜索 31 31 62 2 1081 模拟 32 30 62 4 1293 单调队列 31 31 62 7 1407 扩展欧几里得 32 30 62 5 1588 Splay/Set 27 35 62 4 1811 差分解方程 36 26 62 6 1879 状压DP 33 29 62 6 2190 线性筛欧拉函数 31 31 62 7 2426 贪心 33 29 62 4 2656 高精度 31 31 62 2 2751 快速幂+快速乘 31 31 62 6 3191 DP 36 26 62 6 3517 解方程 40 22 62 6 4233 递推 40 22 62 4 1031 后缀数组 27 36 63 6 1044 二分+DP 33 30 63 6 1076 期望DP 34 29 63 6 1089 递推+高精度 32 31 63 2 1103 树链剖分 27 36 63 6 1198 搜索 31 32 63 2 1208 Splay/Set 29 34 63 3 1216 堆 27 36 63 5 1224 DFS+剪枝 35 28 63 3 1257 数学 36 27 63 7 2150 二分图 32 31 63 8 2172 分类讨论+暴力 35 28 63 2 3155 树状数组 31 32 63 6 4008 期望DP 33 30 63 6 4318 期望 40 23 63 4403 卢卡斯 33 30 63 1269&amp;1507 Splay/STL 28 35 63 3 1416&amp;1498 高精度算概率 31 32 63 4 1010 DP单调性/斜率优化 32 32 64 8 1046 DP+贪心 34 30 64 5 1092 模拟 34 30 64 4 1259 打表 44 20 64 1 1304 树形DP 33 31 64 6 1406 数学 36 28 64 5 1820 DP 35 29 64 7 1996 DP 36 28 64 6 2153 DP斜率优化 32 32 64 5 2302 DP+组合数递推 35 29 64 6 2328 贪心 35 29 64 5 2338 计算几何+排序 32 32 64 6 2600 二分/单调性 34 30 64 6 2660 DP 32 32 64 5 2765 解方程 32 32 64 5 2824 搜索 34 30 64 2 2875 矩阵乘法 31 33 64 7 3175 二分图 33 31 64 9 3208 记忆化搜索 32 32 64 4 3223 Splay翻转 27 37 64 7 3224 Splay 26 38 64 8 3227 DP+打表 34 30 64 2 3288 线性筛+欧拉函数 32 32 64 6 3437 DP斜率优化 32 32 64 7 3444 数学 34 30 64 4 3612 DP 37 27 64 5 4321 DP 40 24 64 4401 枚举约数+树上统计 35 29 64 1007 单调栈 33 32 65 8 1048 记忆化搜索 34 31 65 6 1051 tarjan 30 35 65 5 1058 Splay/Set 29 36 65 4 1068 记忆化搜索 35 30 65 7 1087 状压DP 33 32 65 6 1202 并查集 33 32 65 8 1220 数学+高精度 34 31 65 2 1237 DP 39 26 65 6 1491 Floyd 33 32 65 7 1560 DP小优化 36 29 65 7 1801 DP 34 31 65 7 1864 树形DP 33 32 65 6 1899 DP 35 30 65 6 1911 DP斜率优化 32 33 65 8 1912 树上最长链 34 31 65 6 1925 DP 35 30 65 7 1966 DP 35 30 65 4 2049 LCT 27 38 65 7 2186 数学 32 33 65 7 2242 快速幂+逆元+BSGS 29 36 65 7 2335 分类讨论 39 26 65 3 2423 DP 36 29 65 6 2431 DP 35 30 65 6 2565 Manacher 33 32 65 7 2729 组合计数高精度 35 30 65 5 2822 卡特兰数+高精度 33 32 65 2 3156 DP斜率优化 32 33 65 6 3173 树状数组+倒求顺序 34 31 65 6 3190 单调栈 33 32 65 8 3212 线段树区间操作 27 38 65 9 3506 Splay 28 37 65 6 3609 博弈 40 25 65 4 3631 树链剖分 28 37 65 6 3643 暴力 33 32 65 4 4325 暴力 26 39 65 4385 单调队列 31 34 65 1787&amp;1832 LCA 31 34 65 6 1789&amp;1830 暴力 34 31 65 5 难度3 题号 算法 思想难度 实现难度 总难度 推荐指数 1003 DP+最短路 33 33 66 7 1029 贪心+堆 34 32 66 7 1032 错误DP 39 27 66 1 1037 DP 38 28 66 7 1057 DP悬线法 33 33 66 7 1060 树形DP 33 33 66 6 1086 树上DFS分块 33 33 66 2 1096 DP斜率优化 33 33 66 8 1149 DFS 34 32 66 6 1193 贪心+暴力 36 30 66 2 1196 二分+最小生成树 34 32 66 7 1212 Trie+DP 33 33 66 3 1222 DP 39 27 66 6 1806 DP 35 31 66 6 1819 暴力+字典树 32 34 66 2 1861 Splay 29 37 66 7 1932 STL 30 36 66 2 2120 暴力 38 28 66 2 2155 高精递推 39 27 66 4 2299 裴蜀定理 39 27 66 4 2330 差分约束 33 33 66 7 2461 DP 35 31 66 4 2466 树形DP 34 32 66 3 2657 构图+树上最长链 33 33 66 6 2762 树状数组 32 34 66 2 2819 树剖博弈 28 38 66 5 3170 曼哈顿距离 36 30 66 6 3172 AC自动机 30 36 66 9 3174 贪心+DP 36 30 66 6 3192 树状数组 34 32 66 5 3209 数位DP 34 32 66 5 3573 树形DP 33 33 66 4 3823 递推统计 35 31 66 4 3997 DP 37 29 66 5 1042 背包DP+容斥原理 35 32 67 7 1072 状压DP 35 32 67 6 1082 二分+搜索判断 34 33 67 6 1090 区间DP 35 32 67 7 1225 搜索+剪枝+高精 33 34 67 2 1277 DP 36 31 67 5 1486 二分+DFS找负环 34 33 67 8 1564 区间DP 35 32 67 6 1794 DP 37 30 67 5 1798 线段树 29 38 67 9 1860 DP 34 33 67 6 2281 博弈+DP 39 28 67 5 2440 二分+莫比乌斯容斥 34 33 67 6 2458 分治计算几何 34 33 67 7 2667 暴枚+解方程判断 35 32 67 6 2746 BFS 30 37 67 3 2767 DP 37 30 67 6 2809 可并堆 33 34 67 8 2818 欧拉函数/莫比乌斯反演 34 33 67 7 3107 构造 40 27 67 5 3226 线段树 30 37 67 4 3287 高精度 32 35 67 2 3555 HASH 34 33 67 5 4196 树链剖分 29 38 67 7 4236 MAP 35 32 67 6 4347 DP 38 29 67 4366 DP讨论 46 21 67 1180&amp;2843 LCT 28 39 67 5 1786&amp;1831 DP 36 31 67 5 1408 数论 40 28 68 2 1412 网络流 33 35 68 5 1434 博弈论 43 25 68 5 1497 最小割 33 35 68 9 1503 Splay 30 38 68 8 1562 二分图DFS序 34 34 68 8 1567 二分+HASH 34 34 68 5 1597 排序+DP斜率优化 34 34 68 8 1826 贪心+堆 35 33 68 7 1833 数位DP 34 34 68 7 1922 Dijkstra堆优 33 35 68 9 2038 莫队 32 36 68 9 2111 排列组合 34 34 68 3 2118 最短路 35 33 68 8 2160 Manacher+快速幂 34 34 68 7 2227 高精算概率 35 33 68 2 2654 二分+最小生成树 35 33 68 6 2661 费用流 34 34 68 6 2823 最小圆覆盖 29 39 68 7 3111 DP 35 33 68 6 3207 HASH/莫队/主席树 31 37 68 2 3211 暴力并查集+树状数组 35 33 68 4 3225 线段树扫描 32 36 68 2 3233 线性筛+DP 36 32 68 6 3442 费用流 34 34 68 6 3670 KMP 34 34 68 6 4337 HASH判树同构 33 35 68 4 4364 线段树 31 37 68 4378 树状数组 34 34 68 1056&amp;1862 Trie+Splay 28 40 68 3 1043 计算几何+贪心 33 36 69 7 1066 网络流 34 35 69 8 1221 费用流 35 34 69 9 1264 树状数组优化DP 36 33 69 5 1411 推猜结论 41 28 69 6 1855 DP+单调队列 35 34 69 8 1858 线段树各种操作 30 39 69 8 2002 LCT 31 38 69 6 2131 树状数组优化DP 36 33 69 7 2157 LCT多种操作 29 40 69 7 2226 数学 36 33 69 7 2298 DP 40 29 69 6 2460 拟阵+线性基 37 32 69 6 3105 拟阵+线性基 37 32 69 6 3195 状压DP 37 32 69 5 3289 莫队+BIT 32 37 69 6 3316 二分+单调队列 35 34 69 6 3671 贪心 36 33 69 7 3675 多维DP斜率优化 34 35 69 6 3884 费马+欧拉函数+快速幂 37 32 69 6 4004 线性基 36 33 69 8 4034 DFS序维护树 31 38 69 8 4084 HASH 32 37 69 5 4320 分块 36 33 69 1006 弦图染色 40 30 70 2 1041 数学 44 26 70 7 1052 二分+DFS 37 33 70 4 1150 贪心+堆 38 32 70 8 1151 状压DP 36 34 70 7 1188 博弈论SG函数 37 33 70 7 1483 链表启发式合并 35 35 70 7 1566 DP 38 32 70 7 1570 二分+网络流 35 35 70 4 1818 离散化+树状数组 35 35 70 5 1857 三分套三分 34 36 70 7 1877 费用流 36 34 70 7 1878 离线树状数组 36 34 70 8 1898 矩阵乘法 35 35 70 6 1923 高斯消元 36 34 70 8 2037 区间DP 39 31 70 7 2152 点分治 33 37 70 7 2243 树链剖分 30 40 70 7 2339 排列组合+快速幂 40 30 70 5 2424 费用流 36 34 70 7 2439 DP单调优化+扫描 37 33 70 5 2468 数学公式优化 38 32 70 6 2666 贪心调整 40 30 70 7 2957 分块 35 35 70 6 3109 搜索 32 38 70 5 3124 树形DP 36 34 70 6 3193 DP 40 30 70 6 3240 费马小定理+矩阵乘法 35 35 70 7 3436 差分约束+判负环 36 34 70 7 3531 树链剖分 30 40 70 7 3562 缩点+并查集 35 35 70 2 3624 最小生成树+贪心 37 33 70 6 3676 回文自动机 33 37 70 8 3680 模拟退火 33 37 70 8 3685 线段树 31 39 70 4 3732 Kruskal+树上倍增 34 36 70 8 3813 线段树+逆元 32 38 70 7 3930 数学 41 29 70 4 3993 二分+网络流 35 35 70 7 4003 可并堆 34 36 70 8 4027 树形DP 37 33 70 5 4031 矩阵树定理 35 35 70 7 4198 K叉哈夫曼 37 33 70 7 4319 构造SA 40 30 70 5 4338 分解质因数 38 32 70 4349 最小树形图 31 39 70 8 4370 线段树 30 40 70 1040 环+外向树DP 34 37 71 8 1063 树形DP 37 34 71 8 1070 费用流 37 34 71 7 1071 单调扫描 38 33 71 7 1143 Floyd+二分图 38 33 71 8 1217 树形贪心 38 33 71 7 1297 矩阵乘法 37 34 71 8 1415 期望+记忆化DP 37 34 71 8 1484 贪心调整 42 29 71 7 1799 数位DP 36 35 71 6 1834 最大流+费用流 34 37 71 5 1910 DP 38 33 71 6 1935 离线树状数组 36 35 71 5 1975 K短路 33 38 71 7 2133 树形DP 37 34 71 6 2151 双向链表+贪心+堆 37 34 71 8 2169 DP 41 30 71 7 2245 费用流 36 35 71 6 2257 裴蜀定理 38 33 71 4 2306 倍增+Floyd 37 34 71 7 2326 矩阵乘法 37 34 71 5 2337 期望高斯消元 36 35 71 7 2542 费用流 35 36 71 4 2560 子集DP 39 32 71 7 2743 离线树状数组 36 35 71 8 3130 二分+网络流 36 35 71 7 3231 矩阵乘法 35 36 71 4 3560 数论 37 34 71 6 3566 树形DP 38 33 71 6 3996 网络流 36 35 71 5 4029 模拟 39 32 71 4 4240 树状数组 40 31 71 4244 DP 41 30 71 4312 分类讨论 43 28 71 4 4326 树剖/讨论求链交 32 39 71 7 1306&amp;3139 搜索+剪枝 40 31 71 6 2662&amp;2763 分层图+Dijkstra堆优化 35 36 71 8 1005 Prufer 37 35 72 7 1061 单纯形 34 38 72 8 1069 旋转卡壳 33 39 72 8 1093 tarjan缩点+DP 36 36 72 9 1179 tarjan缩点+SPFA 35 37 72 9 1211 Prufer 39 33 72 3 1227 离散化+树状数组扫描 35 37 72 7 1266 最短路+最小割 35 37 72 8 1499 DP单调优化 35 37 72 6 1568 线段树 34 38 72 6 1823 2-SAT 36 36 72 7 1853 搜索+剪枝+容斥原理 39 33 72 6 1927 费用流 38 34 72 9 2142 扩展lucas 33 39 72 8 2163 最小割 37 35 72 4 2438 tarjan缩点 36 36 72 4 2588 DFS序+可持久化线段树 31 41 72 8 2733 Splay启发式合并 33 39 72 7 2742 数论 39 33 72 5 2749 转化后递推 42 30 72 6 2753 最小生成树 40 32 72 5 2816 LCT 31 41 72 5 2827 动态开点线段树 32 40 72 6 2962 线段树 33 39 72 7 2964 DP 36 36 72 5 3143 期望高斯消元 36 36 72 8 3144 最小割 37 35 72 6 3150 高斯消元 38 34 72 6 3152 贪心+堆 37 35 72 4 3295 分块统计动态逆序对 34 38 72 8 3333 BIT+线段树 34 38 72 5 3507 HASH+DP 37 35 72 5 3570 物理+树状数组 38 34 72 3 3576 博弈论+分块 41 31 72 6 3578 Set+rand Hash 36 36 72 4 3594 DP树状数组优化 39 33 72 4 3620 暴力+KMP 38 34 72 2 3629 判素数+约数和公式+暴力 38 34 72 4 3679 数位DP 36 36 72 5 3738 扩展lucas 32 40 72 5 3810 记忆化+卡常 37 35 72 6 3944 杜教筛 36 36 72 8 3673&amp;3674 可持久化ROPE 36 36 72 4 1016 最小生成树+DFS 40 33 73 6 1030 AC自动机+DP 36 37 73 8 1077 差分约束+Floyd 39 34 73 8 1085 A* 38 35 73 8 1177 分类讨论 36 37 73 4 1189 二分+网络流 37 36 73 6 1223 数位DP+高精度 36 37 73 2 1812 树形DP 40 33 73 8 1822 二分+网络流 35 38 73 4 1933 DP 41 32 73 7 1951 卢卡斯+CRT 38 35 73 7 2115 找环+线性基 38 35 73 8 2124 分类讨论分治+Cheat 40 33 73 2 2141 分块统计动态逆序对 34 39 73 8 2146 凸包+单调队列 37 36 73 5 2425 数位DP 40 33 73 6 2427 tarjan缩点+树上背包 36 37 73 7 2523 智商题 45 28 73 3 2618 半平面交 30 43 73 5 2752 线段树大力维护 33 40 73 7 2844 拟阵+线性基+找规律 40 33 73 6 3085 搜索+剪枝+高精度 35 38 73 2 3140 暴力+二分图匹配 37 36 73 6 3171 费用流 38 35 73 7 3238 后缀数组+单调栈 35 38 73 7 3329 数位DP+矩阵乘法 36 37 73 5 3330 三分套三分 36 37 73 4 3441 BIT+二分 39 34 73 5 3503 异或高斯消元 39 34 73 7 3621 数学 38 35 73 2 3931 最短路+网络流 35 38 73 8 3998 后缀自动机 35 38 73 8 3999 树链剖分 32 41 73 6 4007 DP 37 36 73 7 4028 set+分块 35 38 73 6 4153 链表合并+set 38 35 73 5 4243 并查集统计 39 34 73 4245 按位线性基调整 40 33 73 1934&amp;2768 网络流 38 35 73 8 1014 Splay+二分HASH 34 40 74 8 1017 树形DP 38 36 74 4 1049 LIS+DP 40 34 74 3 1073 K短路 35 39 74 4 1185 旋转卡壳 36 38 74 8 1190 分层背包 40 34 74 7 1226 状压DP 40 34 74 8 1305 二分+网络流 38 36 74 8 1444 AC自动机+矩阵乘法 36 38 74 7 1500 Splay各种操作 33 41 74 10 1875 矩阵乘法+拆边构图 39 35 74 8 1880 最短路+拓扑 37 37 74 7 1930 费用流 40 34 74 7 1941 K-D树 33 41 74 7 2004 矩阵乘法 36 38 74 7 2121 DP 40 34 74 7 2135 贪心+堆 39 35 74 6 2143 Dijkstra堆优不建边分层图 35 39 74 5 2301 容斥+莫比乌斯反演+前缀和 38 36 74 8 2336 搜索+随机化 39 35 74 5 2342 Manacher+并查集 40 34 74 6 2622 最短路变形 39 35 74 6 2648 K-D树 33 41 74 7 2728 推性质+按位统计 41 33 74 6 2958 DP 42 32 74 7 3083 树链剖分+DFS序讨论 34 40 74 7 3122 数列求和分类讨论逆元+BSGS 38 36 74 7 3198 HASH+容斥 36 38 74 6 3294 DP+容斥 41 33 74 8 3534 矩阵树定理 39 35 74 6 3564 最小圆覆盖 34 40 74 3 3744 分块在线统计逆序对 35 39 74 8 3751 HASH判方程 40 34 74 8 3875 SPFA维护DP 39 35 74 6 3932 差分主席树 34 40 74 6 3938 离线李超线段树 34 40 74 7 4000 矩阵乘法 36 38 74 5 4010 拓扑+堆 38 36 74 7 4013 树形DP 39 35 74 7 4033 树形DP 39 35 74 7 4152 排序+最短路 38 36 74 5 4237 分治+统计 37 37 74 4239 优先队列+二分 38 36 74 4241 分块 34 40 74 4299 主席树 38 36 74 8 1001 平面图转对偶图+最短路 37 38 75 8 1004 Poyla定理+DP+逆元 39 36 75 8 1009 KMP+矩阵乘法 38 37 75 8 1021 DP+优化 39 36 75 7 1027 凸包+最短路 36 39 75 4 1067 线段树分类讨论 36 39 75 2 1195 AC自动机+状压BFS 37 38 75 4 1449 费用流 40 35 75 8 1453 线段树+并查集 36 39 75 7 1917 树形贪心 43 32 75 7 1924 tarjan 35 40 75 4 1937 KM 39 36 75 7 2119 分段HASH 40 35 75 7 2128 按权值分块 35 40 75 7 2164 树剖背包 33 42 75 6 2244 三维偏序 36 39 75 4 2303 并查集+讨论 41 34 75 7 2561 网络流 39 36 75 6 2744 转化后二分图 40 35 75 6 2746 AC自动机+FAIL树LCA 37 38 75 7 2750 最短路+DP 41 34 75 7 2956 推公式+分块 40 35 75 6 3091 LCT各种操作大力维护 34 41 75 8 3112 单纯形 36 39 75 7 3203 三分+单调队列 38 37 75 6 3597 二分+DFS找负环 41 34 75 6 3626 离线树链剖分 34 41 75 6 3636 分治+DP 38 37 75 7 3926 后缀自动机 37 38 75 8 3934 插头DP 38 37 75 6 3956 单调栈+RMQ 41 34 75 7 4002 矩阵乘法+推公式 41 34 75 5 4017 按位统计+树状数组 39 36 75 6 4037 矩阵乘法 38 37 75 5 4289 Dijkstra 39 36 75 4404 BFS+打表 39 36 75 1487&amp;4316 仙人掌DP 36 39 75 7 2109&amp;2535 拓扑逆向加边 40 35 75 7 1194 BFS+tarjan缩点最长路 38 38 76 8 1298 构造 41 35 76 8 1443 二分图+判断 41 35 76 8 1913 极角排序统计贡献 43 33 76 7 1997 2-SAT 40 36 76 4 1998 并查集+置换 40 36 76 7 2007 平面图转对偶图+最短路 38 38 76 7 2129 多次前缀和处理 40 36 76 5 2145 密码学 37 39 76 1 2553 AC自动机+矩阵乘法 37 39 76 7 2568 按位BIT 39 37 76 4 2597 费用流 42 34 76 7 3622 容斥DP 44 32 76 8 3630 最小割 37 39 76 7 3874 单调贪心+三分 40 36 76 4 3990 暴力 40 36 76 7 3991 虚树+SET 35 41 76 8 4128 矩阵求逆 38 38 76 4 4238 生成树找环讨论 41 35 76 4260 (可持久化)Trie树 36 40 76 4380 区间DP 40 36 76 4381 分块暴力 36 40 76 1023 仙人掌求直径 38 39 77 6 1178 线段扫描+贪心+倍增预处理 40 37 77 8 1199 K-D树 35 42 77 6 1294 射线法+BFS 40 37 77 8 1493 线段树染色+讨论 36 41 77 7 2003 搜索+剪枝 41 36 77 6 2006 RMQ+堆 39 38 77 8 2228 DP+单调队列 41 36 77 8 2436 DP+单调优化 42 35 77 7 2595 斯坦纳树 35 42 77 7 2754 AC自动机 38 39 77 6 2756 二分+网络流 40 37 77 7 2811 贪心 40 37 77 7 2879 费用流动态加边 41 36 77 8 3064 线段树 34 43 77 7 3110 树套树 35 42 77 8 3123 DFS序可持久化线段树启发并 34 43 77 8 3131 数位DP+堆 39 38 77 7 3168 高斯求逆+二分图匹配 40 37 77 6 3243 随机化构造 40 37 77 2 3244 DFS序+统计答案 45 32 77 6 3438 最小割 42 35 77 8 3439 Trie+DFS序主席树 36 41 77 7 3504 网络流 41 36 77 5 3527 FFT 37 40 77 8 3641 环套树剖分 35 42 77 8 3669 LCT维护MST 36 41 77 8 4011 朱刘算法推论+树形DP 43 34 77 7 4026 主席树 37 40 77 8 4151 树上DFS 44 33 77 7 4199 后缀树DP 37 40 77 8 4346 树形DP 39 38 77 4377 扫描处理范围 39 38 77 1038 模拟退火 39 39 78 5 1074 计算几何 38 40 78 7 1095 动态树分治 37 41 78 9 1187 插头DP 37 41 78 8 1210 插头DP 37 41 78 1 1502 辛普森积分 38 40 78 7 1559 AC自动机DP+暴力 37 41 78 3 1791 基环树找直径 37 41 78 8 1972 暴力 29 49 78 2 2127 最小割 42 36 78 7 2132 网络流 42 36 78 7 2139 贪心+最小生成树 46 32 78 7 2140 Trie+tarjan 42 36 78 8 2154 莫比乌斯反演 42 36 78 7 2229 分治+最小割 39 39 78 6 2286 虚树DP 37 41 78 7 2333 可并堆套可并堆 36 42 78 7 2428 模拟退火 41 37 78 5 2539 KM 37 41 78 3 2564 凸包 43 35 78 4 2594 离线LCT维护动态MST 36 42 78 8 2730 双联通分量 40 38 78 7 3125 插头DP 37 41 78 7 3129 扩展lucas+容斥 38 40 78 8 3158 网络流 42 36 78 7 3196 树套树 32 46 78 9 3241 分类讨论DP 39 39 78 2 3246 树形DP 40 38 78 7 3530 AC自动机+数位DP 39 39 78 7 3577 网络流RMQ构图 40 38 78 7 3619 BFS构造+暴力 37 41 78 8 3678 Splay 35 43 78 6 4006 斯坦纳树 35 43 78 7 4035 博弈 45 33 78 7 4313 DP 43 35 78 7 4373 线段树 40 38 78 4399 线段树合并 35 43 78 1999&amp;2282 树上DFS+单调队列 40 38 78 7 3157&amp;3516 数学 45 33 78 6 1011 乱搞 49 30 79 2 1064 图论分类讨论 43 36 79 8 1494 最小表示法+矩阵乘法 38 41 79 7 1495 树形DP 41 38 79 7 1565 拓扑+最小割 42 37 79 8 1969 LCT维护边双 37 42 79 7 2137 分类讨论+求K次幂前缀和 39 40 79 6 2170 插头DP 38 41 79 7 2324 Floyd+费用流 42 37 79 8 2437 二分图+判断 43 36 79 8 2668 费用流 44 35 79 8 2669 DP+搜索容斥 42 37 79 6 2876 二分+数学 46 33 79 5 3242 环套树DP 38 41 79 7 3571 分治+KM 40 39 79 6 3611 虚树DP 37 42 79 8 3873 悬线法+根号分类讨论 39 40 79 6 3876 费用流 43 36 79 7 3935 单纯形 40 39 79 6 4005 数形结合 47 32 79 6 4336 树剖套set 33 46 79 6 4345 堆 41 38 79 4358 分块+并查集 40 39 79 4361 DP+BIT优化+容斥 45 34 79 1018 线段树维护连通性+大力讨论 37 43 80 8 1492 CDQ分治优化DP 40 40 80 8 1926 分块+莫队 36 44 80 7 2000 双端链表 44 36 80 8 2034 贪心调整 47 33 80 7 2159 二项式定理斯特林+树DP 45 35 80 7 2441 BIT+扫描线 40 40 80 3 2547 二分BFS+匈牙利 41 39 80 6 2707 tarjan+期望高斯 40 40 80 8 2734 状压DP 47 33 80 7 2741 分块+可持久化Trie 38 42 80 7 3513 FFT 40 40 80 8 3533 线段树+凸壳三分 37 43 80 6 3561 莫比乌斯反演 44 36 80 8 3720 块状树 37 43 80 7 3743 树形DP 38 42 80 7 4025 LCT维护二分图 37 43 80 7 4032 后缀自动机+序列自动机+BFS 40 40 80 7 4154 K-D树 37 43 80 8 4155 网络流+bitset压位DP 40 40 80 5 4242 BFS建图+货车运输 39 41 80 8 4317 动态树分治 37 43 80 6 4386 矩阵乘法 41 39 80 8 难度4 题号 算法 思想难度 实现难度 总难度 推荐指数 1033 模拟 31 50 81 8 1094 计算几何 39 42 81 7 1200 贪心+DP 47 34 81 8 2039 最小割 44 37 81 7 2331 插头DP 39 42 81 5 2433 计算几何+最短路 43 38 81 7 2459 线段树维护连通性+大力讨论 37 44 81 7 2548 暴力模拟 30 51 81 7 2726 CDQ分治优化DP 41 40 81 6 2806 广义后缀自动机+DP单调优化 41 40 81 8 3309 莫比乌斯反演+推性质 44 37 81 7 3677 树形DP 43 38 81 6 3786 Splay维护括号序列 38 43 81 6 3811 线性基+暴力 44 37 81 7 3925 子集DP 46 35 81 8 4016 Dijkstra+树分治 37 44 81 5 4036 反演子集求概率 50 31 81 7 4180 后缀自动机+倍增DP 41 40 81 6 4311 分治线段树挂链+凸壳三分 38 43 81 8 4372 动态树分治+BIT 37 44 81 6 4383 线段树挂链 39 42 81 2961&amp;4140 二进制分组+凸壳三分 39 42 81 8 1758 树分治+二分+单调队列 39 43 82 8 1797 最小割+tarjan判断 43 39 82 7 1835 线段树优化DP 43 39 82 8 2125 静态仙人掌 39 43 82 7 2780 广义后缀自动机+离线BIT 40 42 82 8 2960 平面图转对偶图+最小树形图 36 46 82 7 3232 二分+网络流 45 37 82 7 3529 莫比乌斯反演+离线树状数组 43 39 82 8 3532 网络流 44 38 82 8 3879 后缀树+虚树 36 46 82 6 4129 树上带修莫队+权值分块 38 44 82 8 4197 状压DP 45 37 82 8 4246 极角排序扫描统计贡献 45 37 82 4310 二分+后缀树 40 42 82 7 4384 乱搞+Cheat 45 37 82 1974 转化后DP 46 37 83 8 2001 动态MST 40 43 83 8 2126 转化后状压矩乘 45 38 83 8 2671 莫比乌斯反演 47 36 83 6 2959 LCT维护边双 39 44 83 8 3218 主席树优化网络流 42 41 83 8 3229 石子合并加强 48 35 83 3 3482 分层图最短路+单调统计 42 41 83 8 3994 莫比乌斯反演 46 37 83 7 3995 线段树维护连通性 38 45 83 7 4092 DP 47 36 83 8 2209&amp;2329 Splay大力维护 39 44 83 8 1558 线段树大力维护 41 43 84 8 2434 AC自动机+FAIL树状数组 43 41 84 8 2878 基环树DP 41 43 84 7 3160 FFT+Manacher 42 42 84 8 3637 有向LCT维护虚边 40 44 84 8 3672 树剖+凸壳三分 39 45 84 8 3681 主席树合并优化网络流 43 41 84 8 3730 动态树分治+动态开点线段树 38 46 84 7 3745 单调队列+线段树大力维护 40 44 84 7 4134 博弈+Trie合并 44 40 84 7 4367 主席树 42 42 84 8 4389 LCT维护虚边 38 46 84 8 4402 计数 45 39 84 2613 置换+构造 46 39 85 6 2651 树形DP 40 45 85 7 2815 LCA重构树 47 38 85 7 3514 LCT维护MST+主席树 40 45 85 8 3591 状压DP 50 35 85 8 3616 K-D树+BITSET 41 44 85 8 3640 高斯求逆优化 48 37 85 8 3817 类欧几里得 50 35 85 6 4066 K-D树+重建 37 48 85 8 1065 环套树DP 48 38 86 8 2555 后缀自动机+LCT 38 48 86 8 3519 Set大力维护 36 50 86 8 3572 虚树 39 47 86 8 3812 DP+容斥 50 36 86 7 3992 NTT+DP快速幂优化 45 41 86 8 4379 树形DP 40 46 86 1414 Manacher+RMQ+单调队列 46 41 87 8 2040 树剖+线段树模拟费用流 39 48 87 7 3461 CDQ分治优化DP 46 41 87 8 3489 三维K-D树 43 44 87 8 3639 有向LCT维护虚边 41 46 87 8 4012 可持久化树链剖分 40 47 87 8 3237&amp;3563&amp;3569 随机化造树+线性基 50 37 87 8 3065 替罪羊树套权值线段树 39 49 88 9 3413 后缀树+主席树 42 46 88 8 3512 杜教筛+莫比乌斯反演 51 37 88 8 3600 替罪羊树+线段树 46 42 88 8 4545 后缀自动机+LCT 39 49 88 8 1062 树状数组 51 38 89 8 2144 转化为LCA后二分+快速统计 53 36 89 8 2149 CDQ分治优化DP 46 43 89 8 2653 按值建主席树 43 46 89 8 3551 Kruskal重构树+DFS序主席树 49 40 89 8 4382 HASH+单调扫描 50 39 89 2162 转化后网络流+容斥DP 51 39 90 8 3814 插头DP 41 49 90 7 1020 迭代法+射线法+点到线段距离 43 48 91 8 4348 暴力 41 50 91 8 2566 动态树分治+map套set 41 51 92 7 2965 平面图转对偶图+枚举+最小割 43 51 94 8 2658 fhqtreap 52 43 95 8 2759 LCT维护环套树大力讨论 48 48 96 8]]></content>
      <tags>
        <tag>题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树学习笔记]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[近日新学习了线段树，总结一下它的用法和注意事项。 query和modify都不需要取$mid$，只有build需要。 有取模时应该每步取模。 区间的端点现算出来而不记录会更快，可以记录区间的长度。 如果有多种操作且不可叠加时pushdown放在前面，且特判叶结点；如果操作可叠加或者只有一种就放在后面。 模板1 已知一个数列，进行两种操作： 将某区间每一个数加上一个数； 求出某区间每一个数的和； 区间修改，区间查询，最简单的模板。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;iostream&gt;typedef long long ll;const int N = 100005;int n, m;ll a[N], ret;struct Node &#123; int len; Node *lc, *rc; ll sum, tag; Node() &#123;&#125; Node(ll val) : len(1), lc(NULL), rc(NULL), sum(val), tag(0) &#123;&#125; Node(Node *lc, Node *rc, int l) : len(l), lc(lc), rc(rc), tag(0) &#123; sum = lc-&gt;sum + rc-&gt;sum; &#125; void add(ll d) &#123; sum += len * d; tag += d; &#125; void pushdown() &#123; if (tag) &#123; lc-&gt;add(tag); rc-&gt;add(tag); tag = 0; &#125; &#125; void modify(int l, int r, int nl, int nr, ll d) &#123; if (nr &lt; l || r &lt; nl) return; if (l &lt;= nl &amp;&amp; nr &lt;= r) &#123; add(d); return; &#125; pushdown(); int mid = (nl + nr) &gt;&gt; 1; lc-&gt;modify(l, r, nl, mid, d); rc-&gt;modify(l, r, mid + 1, nr, d); sum = lc-&gt;sum + rc-&gt;sum; &#125; void query(int l, int r, int nl, int nr) &#123; if (nr &lt; l || r &lt; nl) return; if (l &lt;= nl &amp;&amp; nr &lt;= r) &#123; ret += sum; return; &#125; pushdown(); int mid = (nl + nr) &gt;&gt; 1; lc-&gt;query(l, r, nl, mid); rc-&gt;query(l, r, mid + 1, nr); &#125;&#125; *segt, tpool[N &lt;&lt; 1], *tcur = tpool;Node *build (int l, int r) &#123; if (l == r) return new(tcur++) Node(a[l]); int mid = (l + r) &gt;&gt; 1; return new(tcur++) Node(build(l, mid), build(mid + 1, r), r - l + 1);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf("%lld", &amp;a[i]); segt = build(1, n); int s, x, y; ll k; for (int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d", &amp;s, &amp;x, &amp;y); if (s == 1) &#123; scanf("%lld", &amp;k); segt-&gt;modify(x, y, 1, n, k); &#125; else &#123; ret = 0; segt-&gt;query(x, y, 1, n); printf("%lld\n", ret); &#125; &#125; return 0;&#125; 模板2 已知一个数列，进行两种操作： 将某区间每一个数乘上一个数； 将某区间每一个数加上一个数； 求出某区间每一个数的和 区间修改，区间查询，修改有加有乘。 在结点维护$kx+b$，$k$和$b$分开算，在乘$k$时把$k$和$b$都乘$k$，$k$初始化为$1$。 注意把pushdown放在前面，每次修改前先下传标记。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;typedef long long ll;const int N = 100005;int n, m;ll MOD, a[N];struct Node &#123; int l, r; Node *lc, *rc; ll sum, k, b; Node() &#123;&#125; Node(int pos, ll val) : l(pos), r(pos), lc(NULL), rc(NULL), sum(val), k(1), b(0) &#123;&#125; Node(Node *lc, Node *rc) : l(lc-&gt;l), r(rc-&gt;r), lc(lc), rc(rc), k(1), b(0) &#123; sum = (lc-&gt;sum + rc-&gt;sum) % MOD; &#125; void addk(ll d) &#123; sum = sum * d % MOD; k = k * d % MOD; b = b * d % MOD; &#125; void addb(ll d) &#123; sum = (sum + (r - l + 1) * d) % MOD; b = (b + d) % MOD; &#125; void pushdown() &#123; if (k != 1) &#123; lc-&gt;addk(k); rc-&gt;addk(k); k = 1; &#125; if (b) &#123; lc-&gt;addb(b); rc-&gt;addb(b); b = 0; &#125; &#125; void modify(int s, int l, int r, ll d) &#123; if (r &lt; this-&gt;l || this-&gt;r &lt; l) return; if (this-&gt;l != this-&gt;r) pushdown(); if (l &lt;= this-&gt;l &amp;&amp; this-&gt;r &lt;= r) &#123; if (s == 1) addk(d); else addb(d); return; &#125; lc-&gt;modify(s, l, r, d); rc-&gt;modify(s, l, r, d); sum = (lc-&gt;sum + rc-&gt;sum) % MOD; &#125; ll query(int l, int r) &#123; if (r &lt; this-&gt;l || this-&gt;r &lt; l) return 0; if (this-&gt;l != this-&gt;r) pushdown(); if (l &lt;= this-&gt;l &amp;&amp; this-&gt;r &lt;= r) return sum; return (lc-&gt;query(l, r) + rc-&gt;query(l, r)) % MOD; &#125;&#125; *root, tpool[N &lt;&lt; 1], *tcur = tpool;Node *build(int l, int r) &#123; if (l == r) return new (tcur++) Node(l, a[l]); int mid = (l + r) &gt;&gt; 1; return new (tcur++) Node(build(l, mid), build(mid + 1, r));&#125;int main() &#123; scanf("%d%d%lld", &amp;n, &amp;m, &amp;MOD); for (int i = 1; i &lt;= n; ++i) scanf("%lld", &amp;a[i]); root = build(1, n); int p, x, y; ll d; for (int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d", &amp;p, &amp;x, &amp;y); if (p == 3) printf("%lld\n", root-&gt;query(x, y)); else &#123; scanf("%lld", &amp;d); root-&gt;modify(p, x, y, d); &#125; &#125; return 0;&#125; 模板3 已知一个数列，进行5种操作： 把区间内的所有数都增加一个数； 把区间内的所有数都设为一个数； 查询区间的区间和； 查询区间的最大值； 查询区间的最小值。 要维护的量比较多，注意set和add的顺序。 这里放了kyr1no学长的代码$Orz$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;bits/stdc++.h&gt;typedef long long ll;typedef const int cint;typedef const long long cll;typedef const char cchar;#define daze &lt;&lt; '\n'template &lt;cint LI, cint LO&gt;struct IO &#123; char a[LI], b[LO], r[LO], *s, *t, *z, c; std::streambuf *fbi, *fbo; IO() : z(b) &#123; std::ios::sync_with_stdio(false); if (LI) std::cin.tie(NULL), fbi = std::cin.rdbuf(); if (LO) std::cout.tie(NULL), fbo = std::cout.rdbuf(); &#125; ~IO() &#123; if (LO) fbo-&gt;sputn(b, z - b); &#125; char gc() &#123; if (s == t) t = (s = a) + fbi-&gt;sgetn(a, LI); return s == t ? EOF : *s++; &#125; template &lt;class T&gt; IO &amp;operator &gt;&gt; (T &amp;x) &#123; for (c = gc(); c != '-' &amp;&amp; !isdigit(c); c = gc()); bool f = c == '-'; x = (f ? gc() : c) - '0'; for (c = gc(); isdigit(c); c = gc()) x = x * 10 + (c - '0'); if (f) x = -x; return *this; &#125; char *gs(char *x) &#123; for (c = gc(); !isgraph(c); c = gc()); for (*x++ = c, c = gc(); isgraph(c); *x++ = c, c = gc()); return *x = 0, x; &#125; IO &amp;operator &gt;&gt; (char *x) &#123; for (c = gc(); !isgraph(c); c = gc()); for (*x++ = c, c = gc(); isgraph(c); *x++ = c, c = gc()); return *x = 0, *this; &#125; IO &amp;operator &gt;&gt; (char &amp;x) &#123; for (x = gc(); !isgraph(x); x = gc()); return *this; &#125; template &lt;class T&gt; operator T () &#123; T x; *this &gt;&gt; x; return x; &#125; void pc(cchar x) &#123; if (z == b + LO) fbo-&gt;sputn(z = b, LO); *z++ = x; &#125; void fl() &#123; fbo-&gt;sputn(b, z - b); z = b; &#125; template &lt;class T&gt; IO &amp;operator &lt;&lt; (T x) &#123; if (x == 0) return pc('0'), *this; if (x &lt; 0) pc('-'), x = -x; char *j = r; for (T y; x; x = y) y = x / 10, *j++ = x - y * 10 + '0'; while (j != r) pc(*--j); return *this; &#125; IO &amp;operator &lt;&lt; (char *x) &#123; while (*x) pc(*x++); return *this; &#125; IO &amp;operator &lt;&lt; (cchar *x) &#123; while (*x) pc(*x++); return *this; &#125; IO &amp;operator &lt;&lt; (cchar x) &#123; return pc(x), *this; &#125;&#125;;IO&lt;1000000, 1000000&gt; io;cint N = 100003;int n;ll ret;inline ll fsum(cll x, cll y) &#123; return x + y;&#125;struct Node &#123; Node *lc, *rc; int len; ll sum, min, max, tgs, tga; // tgs goes first Node() &#123;&#125; Node(cll x) : lc(NULL), rc(NULL), len(1), sum(x), min(x), max(x), tgs(LLONG_MIN), tga(0) &#123;&#125; Node(Node *l, Node *r, cint le) : lc(l), rc(r), len(le), tgs(LLONG_MIN), tga(0) &#123; maintain(); &#125; void maintain() &#123; sum = lc-&gt;sum + rc-&gt;sum; min = std::min(lc-&gt;min, rc-&gt;min); max = std::max(lc-&gt;max, rc-&gt;max); &#125; void cover_s(cll x) &#123; sum = x * len; min = max = tgs = x; tga = 0; &#125; void cover_a(cll x) &#123; sum += x * len; min += x; max += x; tga += x; &#125; void push_down() &#123; if (tgs != LLONG_MIN) &#123; lc-&gt;cover_s(tgs); rc-&gt;cover_s(tgs); tgs = LLONG_MIN; &#125; if (tga) &#123; lc-&gt;cover_a(tga); rc-&gt;cover_a(tga); tga = 0; &#125; &#125;#define MODIFY_FUNC(func, coverrer) \ void func(cint ql, cint qr, cll x, cint l = 1, cint r = n) &#123; \ if (qr &lt; l || r &lt; ql) \ return; \ if (ql &lt;= l &amp;&amp; r &lt;= qr) \ return coverrer(x); \ push_down(); \ int mid = (l + r) &gt;&gt; 1; \ if (ql &lt;= mid) \ lc-&gt;func(ql, qr, x, l, mid); \ if (qr &gt; mid) \ rc-&gt;func(ql, qr, x, mid + 1, r); \ maintain(); \ &#125;#define QUERY_FUNC(func, attr, opt) \ void func(cint ql, cint qr, cint l = 1, cint r = n) &#123; \ if (qr &lt; l || r &lt; ql) \ return; \ if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; \ ret = opt(ret, attr); \ return; \ &#125; \ push_down(); \ int mid = (l + r) &gt;&gt; 1; \ if (ql &lt;= mid) \ lc-&gt;func(ql, qr, l, mid); \ if (qr &gt; mid) \ rc-&gt;func(ql, qr, mid + 1, r); \ &#125; MODIFY_FUNC(add, cover_a); MODIFY_FUNC(set, cover_s); QUERY_FUNC(qmin, min, std::min); QUERY_FUNC(qmax, max, std::max); QUERY_FUNC(qsum, sum, fsum);&#125; *segt;Node *build(cint l, cint r) &#123; static Node pool[N &lt;&lt; 1], *curr = pool; if (l == r) return new (curr++) Node((ll)io); int mid = (l + r) &gt;&gt; 1; Node *lc = build(l, mid); return new (curr++) Node(lc, build(mid + 1, r), r - l + 1);&#125;int main() &#123; int m; io &gt;&gt; n &gt;&gt; m; segt = build(1, n); char opt[6]; while (m--) &#123; int l, r; io &gt;&gt; opt &gt;&gt; l &gt;&gt; r; if (opt[0] == 's') &#123; if (opt[1] == 'u') ret = 0, segt-&gt;qsum(l, r), io &lt;&lt; ret daze; else segt-&gt;set(l, r, io); &#125; else if (opt[0] == 'm') &#123; if (opt[1] == 'i') ret = LLONG_MAX, segt-&gt;qmin(l, r); else ret = LLONG_MIN, segt-&gt;qmax(l, r); io &lt;&lt; ret daze; &#125; else segt-&gt;add(l, r, io); &#125;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2018%2F12%2F15%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux系统和软件配置。 非常耗时，不能把精力用在这上面，学OI才是正事。 VIM置换ESC和CapsLock： 在/usr/share/X11/xkb/symbols/pc中调换key &lt;ESC&gt;与key &lt;CAPS&gt;两行中括号中的内容。 安装xclip来让nvim支持系统剪切板。 临时： 1xmodmap -e &apos;clear Lock&apos; -e &apos;keycode x042=Escape&apos; 安装Plug插件 1curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 平时的Neovim配置（安装vim实时预览插件需要安装nodejs和npm，详见说明）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445set number ignorecase smartindent noswapfile termguicolors expandtabset mouse=a history=1000 shiftwidth=4 tabstop=4 scrolloff=5inoremap &#123;&lt;CR&gt; &#123;&lt;Esc&gt;o&#125;&lt;Esc&gt;Onoremap ; :noremap j gjnoremap gj jnoremap k gknoremap gk knoremap &lt;F8&gt; ggVG&quot;+yautocmd FileType cpp noremap &lt;F4&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -O2 -Wall -Wshadow -o %&lt; &lt;CR&gt;autocmd FileType cpp inoremap &lt;F4&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -O2 -Wall -Wshadow -o %&lt; &lt;CR&gt;autocmd FileType cpp noremap &lt;F5&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -O2 -Wall -Wshadow -o %&lt; &amp;&amp; time ./%&lt; &lt;CR&gt;autocmd FileType cpp inoremap &lt;F5&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -O2 -Wall -Wshadow -o %&lt; &amp;&amp; time ./%&lt; &lt;CR&gt;autocmd FileType cpp noremap &lt;F7&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -Og -g -Wall -Wshadow -o %&lt; &lt;CR&gt;autocmd FileType cpp inoremap &lt;F7&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -Og -g -Wall -Wshadow -o %&lt; &lt;CR&gt;&quot;------------------------------------------------------------------------------&quot;call plug#begin()Plug &apos;vim-airline/vim-airline&apos;Plug &apos;vim-airline/vim-airline-themes&apos;Plug &apos;tpope/vim-commentary&apos;Plug &apos;w0rp/ale&apos;Plug &apos;vim-scripts/fcitx.vim&apos;Plug &apos;plasticboy/vim-markdown&apos;Plug &apos;suan/vim-instant-markdown&apos;Plug &apos;joker1007/vim-markdown-quote-syntax&apos;Plug &apos;hzchirs/vim-material&apos;call plug#end()&quot;Materiallet g:material_style = &apos;palenight&apos;colorscheme vim-materialhi Normal guibg=NONE ctermbg=NONE&quot;Markdownlet g:vim_markdown_math = 1&quot;Airlinelet g:airline#extensions#tabline#enabled = 1let g:airline_powerline_fonts = 1&quot;Alelet g:ale_sign_column_always = 1let g:ale_lint_on_text_changed = &apos;never&apos; 考试的配置（考场上用缩写）： 12345678910set number ruler ignorecase showcmd expandtabset autoread autoindent smartindentset mouse=a history=1000 shiftwidth=4 tabstop=4 scrolloff=5imap &#123;&lt;CR&gt; &#123;&lt;Esc&gt;o&#125;&lt;Esc&gt;Omap ; :map &lt;F4&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -O2 -Wall -Wshadow -o %&lt; &lt;CR&gt;imap &lt;F4&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -O2 -Wall -Wshadow -o %&lt; &lt;CR&gt;map &lt;F5&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -O2 -Wall -Wshadow -o %&lt; &amp;&amp; time ./%&lt; &lt;CR&gt;imap &lt;F5&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -O2 -Wall -Wshadow -o %&lt; &amp;&amp; time ./%&lt; &lt;CR&gt;map &lt;F7&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -Og -g -Wall -Wshadow -o %&lt; &lt;CR&gt; 更新python-nvim 123sudo pacman -S python-pip python3-pippip install neovim --upgradepip3 install neovim --upgrade 函数名高亮：在/usr/share/nvim/syntax/c.vim后添加 1234&quot;highlight Functionssyn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;[^()]*)(&quot;me=e-2syn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;\s*(&quot;me=e-1hi cFunctions gui=NONE cterm=bold ctermfg=blue 挂载磁盘建好文件夹，在fstab中加入 12/dev/sda2 /D ntfs defaults 0 0/dev/sda3 /E ntfs defaults 0 0 软件源配置官方镜像源 1sudo pacman-mirrors -i -c China -m rank 在配置文件/etc/pacman.conf后添加 123[archlinuxcn]Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$archServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 导入GPG key 12sudo pacman -Syyusudo pacman -S archlinuxcn-keyring 清理无用软件和缓存 12sudo pacman -R $(pacman -Qdtq)sudo pacman -Scc 软件和插件安装软件 123456qtxselfcitxpakkuxorg-xrandrgnome-terminal-transparency //终端透明 Gnome插件 12345AlternateTab Applications Menu Dash to Panel TopIcons Plus User Themes 字体把字体复制到/usr/share/fonts/，刷新缓存1sudo fc-cache -fv 输入法123sudo pacman -S fcitx-sogoupinyinsudo pacman -S fcitx-imsudo pacman -S fcitx-configtool 在配置文件~/.xprofile后添加 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 修改grub修改配置文件/boot/grub/grub.cfg Zsh安装oh-my-zsh 1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 更改默认shell 12sudo chsh -s /bin/zsh vozeosudo chsh -s /bin/zsh 在~/.zshrc中修改 1234agnostersudoalias vim=&apos;nvim&apos;alias pc=&apos;proxychains&apos; 刷新 1source ~/.zshrc 代理在ProxySwitch中更改gfwlist 用代理在终端中打开1chromium --proxy_server=&quot;socks5://127.0.0.1:1080&quot; 在/etc/proxychains.conf最下方添加1socks5 127.0.0.1 1080]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论基础]]></title>
    <url>%2F2018%2F08%2F19%2F%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数学博大精深。近日复习了一些简单的数论，这里再总结一下。 最大公因数算术基本定理 任何一个大于$1$的正整数都能分解为有限个质数的乘积。 欧几里得算法原理：$\gcd(a,b)=\gcd(b,a \bmod b)$ 复杂度:$O(\log n)$。 代码实现：123int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125; 更相减损术原理：$\gcd(a,b)=\gcd(b,a-b)$ 高精度取余不好做时可用这个代替，实现与欧几里得算法相似。 质数Eratosthenes筛法对于每一个质数，除了自己以外，它的倍数一定不是质数，需要筛去，留下的都是质数。 复杂度$O(n\log\log n)$。（不会证明） 代码实现：123456789101112int pri[N];bool vis[N];void Eratosthenes(int n)&#123; for (int i = 2; i * i &lt;= n; ++i) if (!vis[i]) for(int j = i + i; j &lt;= n; j += i) vis[i] = 1; for (int i = 2; i &lt;= n; i++) if(!vis[i]) pri[++cnt] = i;&#125; 欧拉筛线性筛法。对于每一个数从最小的质因数从小到大开始筛去，保证分解是唯一的，避免重复筛除。用途不仅仅是筛质数哟！ 复杂度$O(n)$。 代码实现：12345678910111213141516int cnt, pri[N];bool vis[N];void prime(int n)&#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) pri[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= n; j++) &#123; vis[j * pri[j]] = 1; if (i % pri[j] == 0) //说明有比pri[j]更小的质数已经筛过它了 break; &#125; &#125;&#125; 当$n&gt;5$时，质数总是出现在$6$的倍数的两侧，可以让$i$每次自增$6$进行优化。此外，当提问次数很大时，还可用$Miller-Rabin$算法进一步降低复杂度。 方程裴蜀定理 关于$x$和$y$的线性丢番图方程$ax+by=d$有解当且仅当$\gcd(a,b)|d$。 扩展欧几里得算法求出两个数的最大公因数，并求出方程$ax+by=\gcd(a,b)$的一组绝对值最小的整数解或判断它无解。 当我们用欧几里得算法求解最大公因数的最后一步， 即$a=\gcd(a,b),b=0$时， 方程$ax+by=\gcd(a,b)$的解为$x=1,y=0$， 即$$a’\times1+b’\times0=\gcd(a,b)$$ 对于每一个已知解的方程，设此时的两个数为$a’,b’$， 则有$a’x+b’y=\gcd(a,b)$， 此时的$a’,b’$时由上一步的$b,a\bmod b$计算得来， 即$a’=b,b’=a\mod b$， $$\Longrightarrow bx+(a\bmod b)y=\gcd(a,b)$$ $$\Longrightarrow bx+(a- \lfloor \frac{a}{b} \rfloor \times b)y=\gcd(a,b)$$ （$\lfloor \rfloor$为向下取整） $$\Longrightarrow ay+b(x- \lfloor \frac{a}{b} \rfloor y)=\gcd(a,b)$$ 设此时的解为$x’,y’$，则$x’=y,y’=x- \lfloor \frac{a}{b} \rfloor y$ 一层层向上递归可得原方程的解。 代码实现：1234567891011int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(a, b, y, x); y -= (a / b) * x; return d;&#125; 此时求出的解为$ax+by=\gcd(a,b)$的一组解$x_0,y_0$，若要求$ax+by=d(\gcd(a,b)|d)$的解， 设$c=\gcd(a,b)$，方程的通解为$$x=x_0\frac{d}{c}+k\frac{b}{c},y=y_0\frac{d}{c}-k\frac{a}{c}(k\in\mathbb{Z})$$ 一次同余方程一元一次同余方程$ax\equiv b\pmod m$ 转化为$ax+my=b$即可。 多元一次同余方程使用中国剩余定理或者多次$exgcd$。 中国剩余定理方程组$$\left\{\begin{aligned}x\equiv a_1\pmod {m_1} \\x\equiv a_2\pmod {m_2}\\……\\x\equiv a_n\pmod {m_n}\end{aligned}\right.$$ （其中$m$两两互质）的通解为$ \sum_{i=1}^{n}M_ia_it_i $，设$ M=\sum_{i=1}^{n} m_i $，其中$M_i=\frac{M}{m_i} $，$t_i$为$M_i$模$m_i$的乘法逆元。 证明：乘$M_i$则整除其他的$m$，乘$t_i$则整除$m_i$，乘$a_i$则模$m_i$为$a$。 扩展中国剩余定理模数$m$不是两两互质，此时扩展中国剩余定理不再适用。 考虑两个不定方程，可用$exgcd$求出他们的通解，将这两个方程转化为一个，模数变成他们的最小公倍数。进行n次即可。 快速幂快速求出$a^b\bmod p$。有递归和位运算两种实现，每次将指数$b$降低为$\frac{b}{2}$。快速乘同理。 复杂度$O(\log n)$。 代码实现：123456789101112int qpow(int a, int b, int p)&#123; int ans = 1; while(b) &#123; if(b &amp; 1) ans = (long long)ans * a % p; a = (long long)a * a % p; b &gt;&gt;= 1; &#125; return ans;&#125; 还有很多，待更。$\LaTeX$真是美妙的工具。]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blog]]></title>
    <url>%2F2018%2F08%2F19%2FBlog%2F</url>
    <content type="text"><![CDATA[今天搭建了博客，把遇到的问题总结一下。 主要参考了网上的教程，后来又按照ouuan的博客重新搭了一遍。 切换到国内npm镜像1npm config set registry https://registry.npm.taobao.org 升级npm1.查看当前版本npm -v2.进行npm自动更新npm install npm@latest -g 升级node1.查看当前版本node -v2.清除缓存sudo npm cache clean -f3.安装node版本管理工具sudo npm install n -g4.升级到最新版本sudo n latest 安装Hexo安装并初始化Hexo 123npm install -g hexohexo initnpm install 将博客上传至GitHub生成SSH 1ssh-keygen 打开~/.ssh/id_rsa.pub向GitHub添加SSH key 输入命令 ssh -T git@github.com ，若出现 Hi yourname! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 表示 SSH 配置成功。 安装deployer 1npm install hexo-deployer-git --save 测试一下Markdown1#include&lt;bits/stdc++.h&gt; 列表delete 分割线 引用 略略略 嘤嘤嘤 喵喵喵 咩咩咩 斜体table 1 2 3 哈哈 呜呜 略略 return 0;]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
