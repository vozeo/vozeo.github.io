<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[系统修复]]></title>
    <url>%2F2019%2F01%2F21%2F%E7%B3%BB%E7%BB%9F%E4%BF%AE%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[最近电脑一直出问题，连着修了5天电脑。总结一下遇到的问题。 仅适用于UEFI+GPT引导。 Windows重建EFI分区需要在磁盘上存在一部分未分配空间（大于100M），重新建立EFI分区并建立引导。 1234567diskpartlist diskselect disk * //选择要重建的EFI分区的编号create partition efi size = 500 //分配给EFI分区的容量format quick fs = fat32exitbcdboot c:\windows 重建UEFI引导在Windows安装盘或者WinPE中给EFI分区分配盘符，重新建立引导。 1bcdboot c:\windows /s g: /f uefi /l zh-cn //g是EFI分区 修复UEFI引导在Windows安装盘或者WinPE中给EFI分区分配盘符。 12345X:&gt; DISKPARTDISKPART&gt; list volDISKPART&gt; sel vol * //设置操作默认卷编号DISKPART&gt; assign letter=G:DISKPART&gt; exit 修复引导记录并重建BCD。 12345cd /d G:\EFI\Microsoft\BootG:\EFI\Microsoft\Boot&gt; bootrec /scanosG:\EFI\Microsoft\Boot&gt; bootrec /fixmbrG:\EFI\Microsoft\Boot&gt; bootrec /fixbootG:\EFI\Microsoft\Boot&gt; bootrec /rebuildbcd 修复BCD。 1G:\EFI\Microsoft\Boot&gt; bcdboot c:\windows /s g: /f all Linux修复grub引导开机出现了grub&gt;使用ls命令罗列所有磁盘分区信息，找到Linux安装分区，设置变量，进入grub启动菜单。 12345grub&gt;lsgrub&gt;root=(hd0,gpt3) grub&gt;prefix=(hd0,gpt3)/boot/grubgrub&gt;insmod /boot/grub/x86_64-efi/normal.modgrub&gt;normal 安装grub用以上方法重新进入Linux后，重新安装grub。 1update-grub 开机显示you are in emergency mode是由于修改了EFI分区，盘符UUID不对所致。查看/var/log/boot.log可看到启动时的UUID；把/etc/fstab中的UUID修改成新盘符的UUID。]]></content>
      <tags>
        <tag>linux, 配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树学习笔记]]></title>
    <url>%2F2018%2F12%2F25%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[近日新学习了线段树，总结一下它的用法和注意事项。 query和modify都不需要取$mid$，只有build需要。 有取模时应该每步取模。 区间的端点现算出来而不记录会更快，可以记录区间的长度。 如果有多种操作且不可叠加时pushdown放在前面，且特判叶结点；如果操作可叠加或者只有一种就放在后面。 模板1 已知一个数列，进行两种操作： 将某区间每一个数加上一个数； 求出某区间每一个数的和； 区间修改，区间查询，最简单的模板。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;iostream&gt;typedef long long ll;const int N = 100005;int n, m;ll a[N], ret;struct Node &#123; int len; Node *lc, *rc; ll sum, tag; Node() &#123;&#125; Node(ll val) : len(1), lc(NULL), rc(NULL), sum(val), tag(0) &#123;&#125; Node(Node *lc, Node *rc, int l) : len(l), lc(lc), rc(rc), tag(0) &#123; sum = lc-&gt;sum + rc-&gt;sum; &#125; void add(ll d) &#123; sum += len * d; tag += d; &#125; void pushdown() &#123; if (tag) &#123; lc-&gt;add(tag); rc-&gt;add(tag); tag = 0; &#125; &#125; void modify(int l, int r, int nl, int nr, ll d) &#123; if (nr &lt; l || r &lt; nl) return; if (l &lt;= nl &amp;&amp; nr &lt;= r) &#123; add(d); return; &#125; pushdown(); int mid = (nl + nr) &gt;&gt; 1; lc-&gt;modify(l, r, nl, mid, d); rc-&gt;modify(l, r, mid + 1, nr, d); sum = lc-&gt;sum + rc-&gt;sum; &#125; void query(int l, int r, int nl, int nr) &#123; if (nr &lt; l || r &lt; nl) return; if (l &lt;= nl &amp;&amp; nr &lt;= r) &#123; ret += sum; return; &#125; pushdown(); int mid = (nl + nr) &gt;&gt; 1; lc-&gt;query(l, r, nl, mid); rc-&gt;query(l, r, mid + 1, nr); &#125;&#125; *segt, tpool[N &lt;&lt; 1], *tcur = tpool;Node *build (int l, int r) &#123; if (l == r) return new(tcur++) Node(a[l]); int mid = (l + r) &gt;&gt; 1; return new(tcur++) Node(build(l, mid), build(mid + 1, r), r - l + 1);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf("%lld", &amp;a[i]); segt = build(1, n); int s, x, y; ll k; for (int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d", &amp;s, &amp;x, &amp;y); if (s == 1) &#123; scanf("%lld", &amp;k); segt-&gt;modify(x, y, 1, n, k); &#125; else &#123; ret = 0; segt-&gt;query(x, y, 1, n); printf("%lld\n", ret); &#125; &#125; return 0;&#125; 模板2 已知一个数列，进行两种操作： 将某区间每一个数乘上一个数； 将某区间每一个数加上一个数； 求出某区间每一个数的和 区间修改，区间查询，修改有加有乘。 在结点维护$kx+b$，$k$和$b$分开算，在乘$k$时把$k$和$b$都乘$k$，$k$初始化为$1$。 注意把pushdown放在前面，每次修改前先下传标记。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;typedef long long ll;const int N = 100005;int n, m;ll MOD, a[N];struct Node &#123; int l, r; Node *lc, *rc; ll sum, k, b; Node() &#123;&#125; Node(int pos, ll val) : l(pos), r(pos), lc(NULL), rc(NULL), sum(val), k(1), b(0) &#123;&#125; Node(Node *lc, Node *rc) : l(lc-&gt;l), r(rc-&gt;r), lc(lc), rc(rc), k(1), b(0) &#123; sum = (lc-&gt;sum + rc-&gt;sum) % MOD; &#125; void addk(ll d) &#123; sum = sum * d % MOD; k = k * d % MOD; b = b * d % MOD; &#125; void addb(ll d) &#123; sum = (sum + (r - l + 1) * d) % MOD; b = (b + d) % MOD; &#125; void pushdown() &#123; if (k != 1) &#123; lc-&gt;addk(k); rc-&gt;addk(k); k = 1; &#125; if (b) &#123; lc-&gt;addb(b); rc-&gt;addb(b); b = 0; &#125; &#125; void modify(int s, int l, int r, ll d) &#123; if (r &lt; this-&gt;l || this-&gt;r &lt; l) return; if (this-&gt;l != this-&gt;r) pushdown(); if (l &lt;= this-&gt;l &amp;&amp; this-&gt;r &lt;= r) &#123; if (s == 1) addk(d); else addb(d); return; &#125; lc-&gt;modify(s, l, r, d); rc-&gt;modify(s, l, r, d); sum = (lc-&gt;sum + rc-&gt;sum) % MOD; &#125; ll query(int l, int r) &#123; if (r &lt; this-&gt;l || this-&gt;r &lt; l) return 0; if (this-&gt;l != this-&gt;r) pushdown(); if (l &lt;= this-&gt;l &amp;&amp; this-&gt;r &lt;= r) return sum; return (lc-&gt;query(l, r) + rc-&gt;query(l, r)) % MOD; &#125;&#125; *root, tpool[N &lt;&lt; 1], *tcur = tpool;Node *build(int l, int r) &#123; if (l == r) return new (tcur++) Node(l, a[l]); int mid = (l + r) &gt;&gt; 1; return new (tcur++) Node(build(l, mid), build(mid + 1, r));&#125;int main() &#123; scanf("%d%d%lld", &amp;n, &amp;m, &amp;MOD); for (int i = 1; i &lt;= n; ++i) scanf("%lld", &amp;a[i]); root = build(1, n); int p, x, y; ll d; for (int i = 1; i &lt;= m; ++i) &#123; scanf("%d%d%d", &amp;p, &amp;x, &amp;y); if (p == 3) printf("%lld\n", root-&gt;query(x, y)); else &#123; scanf("%lld", &amp;d); root-&gt;modify(p, x, y, d); &#125; &#125; return 0;&#125; 模板3 已知一个数列，进行5种操作： 把区间内的所有数都增加一个数； 把区间内的所有数都设为一个数； 查询区间的区间和； 查询区间的最大值； 查询区间的最小值。 要维护的量比较多，注意set和add的顺序。 这里放了王廉杰学长的代码$Orz$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;bits/stdc++.h&gt;typedef long long ll;typedef const int cint;typedef const long long cll;typedef const char cchar;#define daze &lt;&lt; '\n'template &lt;cint LI, cint LO&gt;struct IO &#123; char a[LI], b[LO], r[LO], *s, *t, *z, c; std::streambuf *fbi, *fbo; IO() : z(b) &#123; std::ios::sync_with_stdio(false); if (LI) std::cin.tie(NULL), fbi = std::cin.rdbuf(); if (LO) std::cout.tie(NULL), fbo = std::cout.rdbuf(); &#125; ~IO() &#123; if (LO) fbo-&gt;sputn(b, z - b); &#125; char gc() &#123; if (s == t) t = (s = a) + fbi-&gt;sgetn(a, LI); return s == t ? EOF : *s++; &#125; template &lt;class T&gt; IO &amp;operator &gt;&gt; (T &amp;x) &#123; for (c = gc(); c != '-' &amp;&amp; !isdigit(c); c = gc()); bool f = c == '-'; x = (f ? gc() : c) - '0'; for (c = gc(); isdigit(c); c = gc()) x = x * 10 + (c - '0'); if (f) x = -x; return *this; &#125; char *gs(char *x) &#123; for (c = gc(); !isgraph(c); c = gc()); for (*x++ = c, c = gc(); isgraph(c); *x++ = c, c = gc()); return *x = 0, x; &#125; IO &amp;operator &gt;&gt; (char *x) &#123; for (c = gc(); !isgraph(c); c = gc()); for (*x++ = c, c = gc(); isgraph(c); *x++ = c, c = gc()); return *x = 0, *this; &#125; IO &amp;operator &gt;&gt; (char &amp;x) &#123; for (x = gc(); !isgraph(x); x = gc()); return *this; &#125; template &lt;class T&gt; operator T () &#123; T x; *this &gt;&gt; x; return x; &#125; void pc(cchar x) &#123; if (z == b + LO) fbo-&gt;sputn(z = b, LO); *z++ = x; &#125; void fl() &#123; fbo-&gt;sputn(b, z - b); z = b; &#125; template &lt;class T&gt; IO &amp;operator &lt;&lt; (T x) &#123; if (x == 0) return pc('0'), *this; if (x &lt; 0) pc('-'), x = -x; char *j = r; for (T y; x; x = y) y = x / 10, *j++ = x - y * 10 + '0'; while (j != r) pc(*--j); return *this; &#125; IO &amp;operator &lt;&lt; (char *x) &#123; while (*x) pc(*x++); return *this; &#125; IO &amp;operator &lt;&lt; (cchar *x) &#123; while (*x) pc(*x++); return *this; &#125; IO &amp;operator &lt;&lt; (cchar x) &#123; return pc(x), *this; &#125;&#125;;IO&lt;1000000, 1000000&gt; io;cint N = 100003;int n;ll ret;inline ll fsum(cll x, cll y) &#123; return x + y;&#125;struct Node &#123; Node *lc, *rc; int len; ll sum, min, max, tgs, tga; // tgs goes first Node() &#123;&#125; Node(cll x) : lc(NULL), rc(NULL), len(1), sum(x), min(x), max(x), tgs(LLONG_MIN), tga(0) &#123;&#125; Node(Node *l, Node *r, cint le) : lc(l), rc(r), len(le), tgs(LLONG_MIN), tga(0) &#123; maintain(); &#125; void maintain() &#123; sum = lc-&gt;sum + rc-&gt;sum; min = std::min(lc-&gt;min, rc-&gt;min); max = std::max(lc-&gt;max, rc-&gt;max); &#125; void cover_s(cll x) &#123; sum = x * len; min = max = tgs = x; tga = 0; &#125; void cover_a(cll x) &#123; sum += x * len; min += x; max += x; tga += x; &#125; void push_down() &#123; if (tgs != LLONG_MIN) &#123; lc-&gt;cover_s(tgs); rc-&gt;cover_s(tgs); tgs = LLONG_MIN; &#125; if (tga) &#123; lc-&gt;cover_a(tga); rc-&gt;cover_a(tga); tga = 0; &#125; &#125;#define MODIFY_FUNC(func, coverrer) \ void func(cint ql, cint qr, cll x, cint l = 1, cint r = n) &#123; \ if (qr &lt; l || r &lt; ql) \ return; \ if (ql &lt;= l &amp;&amp; r &lt;= qr) \ return coverrer(x); \ push_down(); \ int mid = (l + r) &gt;&gt; 1; \ if (ql &lt;= mid) \ lc-&gt;func(ql, qr, x, l, mid); \ if (qr &gt; mid) \ rc-&gt;func(ql, qr, x, mid + 1, r); \ maintain(); \ &#125;#define QUERY_FUNC(func, attr, opt) \ void func(cint ql, cint qr, cint l = 1, cint r = n) &#123; \ if (qr &lt; l || r &lt; ql) \ return; \ if (ql &lt;= l &amp;&amp; r &lt;= qr) &#123; \ ret = opt(ret, attr); \ return; \ &#125; \ push_down(); \ int mid = (l + r) &gt;&gt; 1; \ if (ql &lt;= mid) \ lc-&gt;func(ql, qr, l, mid); \ if (qr &gt; mid) \ rc-&gt;func(ql, qr, mid + 1, r); \ &#125; MODIFY_FUNC(add, cover_a); MODIFY_FUNC(set, cover_s); QUERY_FUNC(qmin, min, std::min); QUERY_FUNC(qmax, max, std::max); QUERY_FUNC(qsum, sum, fsum);&#125; *segt;Node *build(cint l, cint r) &#123; static Node pool[N &lt;&lt; 1], *curr = pool; if (l == r) return new (curr++) Node((ll)io); int mid = (l + r) &gt;&gt; 1; Node *lc = build(l, mid); return new (curr++) Node(lc, build(mid + 1, r), r - l + 1);&#125;int main() &#123; int m; io &gt;&gt; n &gt;&gt; m; segt = build(1, n); char opt[6]; while (m--) &#123; int l, r; io &gt;&gt; opt &gt;&gt; l &gt;&gt; r; if (opt[0] == 's') &#123; if (opt[1] == 'u') ret = 0, segt-&gt;qsum(l, r), io &lt;&lt; ret daze; else segt-&gt;set(l, r, io); &#125; else if (opt[0] == 'm') &#123; if (opt[1] == 'i') ret = LLONG_MAX, segt-&gt;qmin(l, r); else ret = LLONG_MIN, segt-&gt;qmax(l, r); io &lt;&lt; ret daze; &#125; else segt-&gt;add(l, r, io); &#125;&#125;]]></content>
      <tags>
        <tag>线段树, 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode配置]]></title>
    <url>%2F2018%2F12%2F23%2FVSCode%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[自己用的VSCode配置。 12345678&#123; &quot;workbench.colorTheme&quot;: &quot;Solarized Dark&quot;, &quot;editor.fontFamily&quot;: &quot;&apos;Fira Code&apos;, Consolas, &apos;Courier New&apos;, monospace&quot;, &quot;editor.fontLigatures&quot;: true, &quot;editor.fontSize&quot;: 16, &quot;C_Cpp.clang_format_style&quot;: &quot;&#123; BasedOnStyle: LLVM, IndentWidth: 4 &#125;&quot;, &quot;C_Cpp.clang_format_fallbackStyle&quot;: &quot;&#123; BasedOnStyle: LLVM, IndentWidth: 4 &#125;&quot;,&#125;]]></content>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见配置]]></title>
    <url>%2F2018%2F12%2F15%2FLinux%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Linux系统和软件配置。 Ubuntu更换软件源在/etc/apt/sources.list下加入软件源（18.04LTS） 1234deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse 配置archlinuxcn源在配置文件/etc/pacman.conf后添加 12345[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.zju.edu.cn/archlinuxcn/$archServer = https://mirrors.ustc.edu.cn/archlinuxcn/$archServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch 导入GPG key 1sudo pacman -Syyu &amp;&amp; sudo pacman -S archlinuxcn-keyring 配置官方镜像源更新镜像排名和数据源 12sudo pacman-mirrors -i -c China -m ranksudo pacman -Syy 更新archlinux签名 1pacman -S archlinux-keyring 安装输入法123sudo pacman -S fcitx-sogoupinyinsudo pacman -S fcitx-imsudo pacman -S fcitx-configtool 在配置文件~/.xprofile后添加 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=&quot;@im=fcitx&quot; 使用可视化界面调节输入法设置 1fcitx-configtool 修改grub修改配置文件/boot/grub/grub.cfg Zsh配置安装zsh shellsudo apt install zsh 安装oh-my-zsh 1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 更改默认shell 12sudo chsh -s /bin/zsh vozeosudo chsh -s /bin/zsh 在zsh配置文件~/.zshrc中修改 123agnostersudoalias vim=&apos;nvim&apos; 下载打包好的powerline字体 修改完以后刷新source ~/.zshrc Nvim配置安装Plug 1curl -fLo ~/.config/nvim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 修改nvim配置~/.config/nvim/init.vim 123456789101112131415161718192021call plug#begin()Plug &apos;vim-airline/vim-airline&apos;Plug &apos;vim-airline/vim-airline-themes&apos;Plug &apos;jiangmiao/auto-pairs&apos;call plug#end()let g:airline#extensions#tabline#enabled=1let g:airline_powerline_fonts=1set numberset rulerset mouse=aset history=1000set ignorecaseset autoindentset smartindentset shiftwidth=4set tabstop=4&quot;imap &#123;&lt;CR&gt; &#123;&lt;ESC&gt;o&#125;&lt;ESC&gt;Oautocmd FileType cpp map &lt;F4&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -O2 -Wall -Wshadow -o ./%&lt; &lt;CR&gt;autocmd FileType cpp map &lt;F5&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -O2 -Wall -Wshadow -o ./%&lt; &amp;&amp; ./%&lt; &lt;CR&gt;autocmd FileType cpp map &lt;F7&gt; &lt;Esc&gt;:w&lt;CR&gt;:!g++ % -Og -g -Wall -Wshadow -o ./%&lt; &amp;&amp; gdb ./%&lt; &lt;CR&gt; 更新python-nvim 123sudo apt install python-pip python3-pippip install neovim --upgradepip3 install neovim --upgrade 函数名高亮在/usr/share/nvim/syntax/c.vim后添加 1234&quot;highlight Functionssyn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;[^()]*)(&quot;me=e-2syn match cFunctions &quot;\&lt;[a-zA-Z_][a-zA-Z_0-9]*\&gt;\s*(&quot;me=e-1hi cFunctions gui=NONE cterm=bold ctermfg=blue 在终端使用代理安装sudo apt install proxychains在/etc/proxychains.conf最下方添加socks5 127.0.0.1 1080 Konsole配色（solarized改进版）前景：灰色#93a1a1背景：蓝黑#002b36颜色1：黑色#073642颜色2：红色#dc322f颜色3：绿色#859900颜色4：黄色#b58900颜色5：蓝色#268bd2颜色6：洋红#d33682颜色7：浅蓝#5ed5fd]]></content>
      <tags>
        <tag>linux, 配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数论基础]]></title>
    <url>%2F2018%2F08%2F19%2F%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[数学博大精深。 最大公因数算术基本定理 任何一个大于$1$的正整数都能分解为有限个质数的乘积。 欧几里得算法原理：$\gcd(a,b)=\gcd(b,a \bmod b)$ 复杂度:$O(\log n)$。 代码实现：1234int gcd(int a, int b)&#123; return b ? gcd(b, a % b) : a;&#125; 更相减损术原理：$\gcd(a,b)=\gcd(b,a-b)$ 高精度取余不好做时可用这个代替，实现与欧几里得算法相似。 质数Eratosthenes筛法对于每一个质数，除了自己以外，它的倍数一定不是质数，需要筛去，留下的都是质数。 复杂度$O(n\log\log n)$。（不会证明） 代码实现：123456789101112int pri[N];bool vis[N];void Eratosthenes(int n)&#123; for (int i = 2; i * i &lt;= n; ++i) if (!vis[i]) for(int j = i + i; j &lt;= n; j += i) vis[i] = 1; for (int i = 2; i &lt;= n; i++) if(!vis[i]) pri[++cnt] = i;&#125; 欧拉筛线性筛法。对于每一个数从最小的质因数从小到大开始筛去，保证分解是唯一的，避免重复筛除。用途不仅仅是筛质数哟！ 复杂度$O(n)$。 代码实现：12345678910111213141516int cnt, pri[N];bool vis[N];void prime(int n)&#123; for (int i = 2; i &lt;= n; i++) &#123; if (!vis[i]) pri[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= n; j++) &#123; vis[j * pri[j]] = 1; if (i % pri[j] == 0) //说明有比pri[j]更小的质数已经筛过它了 break; &#125; &#125;&#125; 当$n&gt;5$时，质数总是出现在$6$的倍数的两侧，可以让$i$每次自增$6$进行优化。此外，当提问次数很大时，还可用$Miller-Rabin$算法进一步降低复杂度。 方程裴蜀定理 关于$x$和$y$的线性丢番图方程$ax+by=d$有解当且仅当$\gcd(a,b)|d$。 扩展欧几里得算法求出两个数的最大公因数，并求出方程$ax+by=\gcd(a,b)$的一组绝对值最小的整数解或判断它无解。 当我们用欧几里得算法求解最大公因数的最后一步， 即$a=\gcd(a,b),b=0$时， 方程$ax+by=\gcd(a,b)$的解为$x=1,y=0$， 即$$a’\times1+b’\times0=\gcd(a,b)$$ 对于每一个已知解的方程，设此时的两个数为$a’,b’$， 则有$a’x+b’y=\gcd(a,b)$， 此时的$a’,b’$时由上一步的$b,a\bmod b$计算得来， 即$a’=b,b’=a\mod b$， $$\Longrightarrow bx+(a\bmod b)y=\gcd(a,b)$$ $$\Longrightarrow bx+(a- \lfloor \frac{a}{b} \rfloor \times b)y=\gcd(a,b)$$ （$\lfloor \rfloor$为向下取整） $$\Longrightarrow ay+b(x- \lfloor \frac{a}{b} \rfloor y)=\gcd(a,b)$$ 设此时的解为$x’,y’$，则$x’=y,y’=x- \lfloor \frac{a}{b} \rfloor y$ 一层层向上递归可得原方程的解。 代码实现：1234567891011int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(!b) &#123; x = 1, y = 0; return a; &#125; int d = exgcd(a, b, y, x); y -= (a / b) * x; return d;&#125; 此时求出的解为$ax+by=\gcd(a,b)$的一组解$x_0,y_0$，若要求$ax+by=d(\gcd(a,b)|d)$的解， 设$c=\gcd(a,b)$，方程的通解为$$x=x_0\frac{d}{c}+k\frac{b}{c},y=y_0\frac{d}{c}-k\frac{a}{c}(k\in\mathbb{Z})$$ 一次同余方程一元一次同余方程$ax\equiv b\pmod m$ 转化为$ax+my=b$即可。 多元一次同余方程使用中国剩余定理或者多次$exgcd$。 中国剩余定理方程组$$\left\{\begin{aligned}x\equiv a_1\pmod {m_1} \\x\equiv a_2\pmod {m_2}\\……\\x\equiv a_n\pmod {m_n}\end{aligned}\right.$$ （其中$m$两两互质）的通解为$ \sum_{i=1}^{n}M_ia_it_i $，设$ M=\sum_{i=1}^{n} m_i $，其中$M_i=\frac{M}{m_i} $，$t_i$为$M_i$模$m_i$的乘法逆元。 证明：乘$M_i$则整除其他的$m$，乘$t_i$则整除$m_i$，乘$a_i$则模$m_i$为$a$。 扩展中国剩余定理模数$m$不是两两互质，此时扩展中国剩余定理不再适用。 考虑两个不定方程，可用$exgcd$求出他们的通解，将这两个方程转化为一个，模数变成他们的最小公倍数。进行n次即可。 快速幂快速求出$a^b\bmod p$。有递归和位运算两种实现，每次将指数$b$降低为$\frac{b}{2}$。快速乘同理。 复杂度$O(\log n)$。 代码实现：123456789101112int qpow(int a, int b, int p)&#123; int ans = 1; while(b) &#123; if(b &amp; 1) ans = (long long)ans * a % p; a = (long long)a * a % p; b &gt;&gt;= 1; &#125; return ans;&#125; 还有很多，待更。$\LaTeX$真是美妙的工具。]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次搭建博客]]></title>
    <url>%2F2018%2F08%2F19%2F%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[今天新搭建了博客，把自己遇到的问题总结一下。 主要参考了网上的教程，后来又按照ouuan的博客重新搭了一遍。 切换到国内npm镜像1npm config set registry https://registry.npm.taobao.org 升级npm1.查看当前版本npm -v2.进行npm自动更新npm install npm@latest -g 升级node1.查看当前版本node -v2.清除缓存sudo npm cache clean -f3.安装node版本管理工具sudo npm install n -g4.升级到最新版本sudo n latest 安装Hexo安装并初始化Hexo 123npm install -g hexohexo initnpm install 将博客上传至GitHub生成SSH 1ssh-keygen 打开~/.ssh/id_rsa.pub向GitHub添加SSH key 输入命令 ssh -T git@github.com ，若出现 Hi yourname! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 表示 SSH 配置成功。 安装deployer 1npm install hexo-deployer-git --save 测试一下markdown1#include&lt;bits/stdc++.h&gt; 列表delete 分割线 引用 略略略 嘤嘤嘤 喵喵喵 咩咩咩 斜体table 1 2 3 哈哈 呜呜 略略 return 0;]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
